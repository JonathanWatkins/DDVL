#pragma warning ( disable : 2586  )  // supresses warning a bug due to icc and boost compilation

// Class header
#include "CSimulation.hpp"

// Custom classes
#include "CParticle.hpp"
#include "CDelLine.hpp"
#include "CDelTriangle.hpp"
#include "CCoord.hpp"
#include "CBin.hpp"
#include "CPin.hpp"
#include "CLineIDs.hpp"
#include "CVersion.hpp"
#include "CRowCount.hpp"

#include "delaunay.hpp"


// STL classes
#include <list>
#include <vector>
#include <iostream>
#include <string>
#include <sstream>
#include <stdlib.h>
#include <time.h>
#include <iomanip>
#include <set>
#include <vector>
#include <omp.h>
#include <limits.h>
	

#if defined(__WINDOWS__)
  #include <windows.h>
#else
  #include <sys/stat.h>
#endif
#include <iomanip>

// Boost libraries
#include <boost/random.hpp>
#include <boost/random/normal_distribution.hpp>
#include <boost/ptr_container/ptr_list.hpp>
#include <boost/math/special_functions.hpp>
//#include <boost/thread.hpp>
#include <boost/math/special_functions/fpclassify.hpp>

#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/ini_parser.hpp>



template<class T>
double gen_normal_3(T &generator)
{
  double rn=0;
  //do {
		rn =generator();
	//}
	//while ( boost::math::isnan((double)rn)==true || boost::math::isinf((double)rn)==true  || rn >1 || rn <-1);
  return rn; 
}


// Using seed for mt as time(0) does not allow runs to be repeated with same seeds
boost::variate_generator<boost::mt19937, boost::normal_distribution<> >
    generator(boost::mt19937(time(0)),
              boost::normal_distribution<>());





bool xSort (CParticle lhs_,CParticle rhs_)
{
	return (lhs_.get_x()<rhs_.get_x());
}


CSimulation::CSimulation()
{
	startTime=clock();
	seedtime = time(0);// 1364376524;
	lasttime=time(0);
	srand ( seedtime );
	
	/*std::stringstream oss;
	oss << "job" << (long int)seedtime*10000+rand()%1000;	
	
	#if defined (__WINDOWS__)
		CreateDirectory (dirStr.c_str(), NULL);
	#else
		mkdir(dirStr.c_str(),0755);	
	#endif	

	jobnum=oss.str();
	*/

	outputpins=false;
	running = false;
	//start_operation();
	//abort_activities_requested = false;
	simulation_time=1;
	simulation_initialised = false;
	//finish_operation();
	paused=false;
	M2=0;
	M2Full=0;
	M2Sum=0;
	M2FullSum=0;
	avXVel=0;
	avYVel=0;
	bathLength=0;
	bathWidth=0;
	channelLength=0;
	channelWidth=0;
	sourceBfield=0;
	sinkBfield=0;
	sourceDensity=0;
	sinkDensity=0;
	cellSize=0;
	vfieldBinSize=0;
	binsize=0;
	Nv=0;
	Nmis=0;
	thermostat="";
	lorentzForce=0;
	jobtag="";
	drawCoordinateGrid=false;
	triangulateReadRun=true;
	calcTrajectories=false;
	Ap=1;
	DTcount=0;
	fcount=0;
	DTtime=0;
	ftime=0;
	zoom=1;
	version.set_versionStr("2.2.2");
  
		
}

void CSimulation::iniread_GeneralParameters() 
{
	std::cout << "Loading parameters\n  from config.ini..." << std::endl;
	boost::property_tree::ptree pt;
	boost::property_tree::ini_parser::read_ini("config.ini", pt);
	
	// geometry variables
	a0= pt.get<double>("GeneralParameters.a0");
	b0=(std::sqrt((double)3)/2.0)*a0;
	
	// analysis variables
	binsize=pt.get<double>("GeneralParameters.binSize");
	
	// physics variables and constants
	pi=pt.get<double>("GeneralParameters.pi");
	Phi=pt.get<double>("GeneralParameters.Phi");
	forceRange=pt.get<double>("GeneralParameters.forceRange");
	eta=pt.get<double>("GeneralParameters.eta");
	kB=pt.get<double>("GeneralParameters.kB");
	mu0=pt.get<double>("GeneralParameters.mu0");
	lambda=pt.get<double>("GeneralParameters.lambda");
	Ap=pt.get<double>("GeneralParameters.Ap");
	
	// simulation variables
	cellSize=pt.get<double>("GeneralParameters.cellSize");
	vfieldBinSize=pt.get<double>("GeneralParameters.vfieldBinSize");
	
	dt=pt.get<double>("GeneralParameters.dt");
	tau=pt.get<double>("GeneralParameters.tau");
	drawInterval=pt.get<int>("GeneralParameters.drawInterval");
	triangulationInterval=pt.get<int>("GeneralParameters.triangulationInterval");
	drawCoordinateGrid=pt.get<bool>("GeneralParameters.drawCoordinateGrid");
	calcTrajectories=pt.get<bool>("GeneralParameters.calcTrajectories");
	thermostat=pt.get<std::string>("GeneralParameters.thermostat");
	
	// channnel disorder
	disorderDensity=pt.get<double>("GeneralParameters.disorderDensity");
	disorderStrength=pt.get<double>("GeneralParameters.disorderStrength");
	disorderRange=pt.get<double>("GeneralParameters.disorderRange");
	
	
	std::cout << "   Parameters loaded." << std::endl <<std::endl;
	
	
	
}

void CSimulation::do_step()
{
	check_for_start();
	
	if (is_paused()) return;

	//std::cout << "RUNNING WITH BOOST SEED AND RAND SEED 1" << std::endl;
	if (0==t%10) std::cout << "t: " << t << std::endl;
	

	calculateFinishTime();

	if (0==runtype)  //runtype=read 
	{
		
		
		if (false==triangulateReadRun)
		{
			//delVortexList.clear();
			vorticesList.clear();
			readSingleDataStep();
		}
		else if (true==triangulateReadRun)
		{
			vorticesList.clear();
			readSingleDataStep();
		}
		if (t<starting_time_step) return;
		
		if (true==triangulateReadRun && 0==t%triangulationInterval)
		{
			//std::cout << "DT STEP t: " << t << " vorticesList size: " << vorticesList.size() << std::endl;
			delaunayTriangulation(vorticesList);
			//std::cout << "DT STEP t: " << t << " delVortexList size: " << delVortexList.size() << std::endl;
			calcSourceB();
			calcSinkB();
			calculateBinnedBfield();
		}
		else if (false==triangulateReadRun && 0==t%triangulationInterval)
			delVortexList=vorticesList;
			
		//if (get_draw())	calcRowCount();	
		
		//else
		//{
		//	std::cout << "t: " << t << " vorticesList size: " << vorticesList.size() << std::endl;
			
		//}
		
		
		// USE THIS CODE TO OUTPUT POSDATA FOR JOBS THAT DID NOT FINISH
		if (t==340000)
		{

			std::fstream tempfile;
			tempfile.open("posdata.txt");
			std::cout << "START POS" << std::endl;
			for(std::list<CParticle>::iterator p = vorticesList.begin();
				p != vorticesList.end(); ++p)
			{
				tempfile  << std::setw(20) << p->get_x() << std::setw(20) << p->get_y();
				
				if ( std::distance(p,vorticesList.end()) != 1 )
				{
					tempfile << std::endl;
				}
			}
			std::cout << "END POS" << std::endl;
			tempfile.close();	
		}
		
		// USE THIS CODE TO OUTPUT POSDATA FOR JOBS THAT DID NOT FINISH
		
		
	}
	else // runtype = write or write with gui
	{
		
		if (channel==geometry) removeEscapedVortices();
		else if (tube==geometry) removeEscapedVorticesTube();
		else if (periodic==geometry) removeEscapedVorticesPeriodic();
	
		clock_t startclock = clock();
		calculateForces();
		ftime+=(clock()-startclock)/(double)CLOCKS_PER_SEC;
		fcount++;
	
	
		// temp
		//delVortexList=vorticesList;	
		//std::cout << "Num: " << delVortexList.size() << std::endl;
		
		if (0==t%triangulationInterval)
		{
			clock_t startclock = clock();
			delaunayTriangulation(vorticesList);
			DTtime+=(clock()-startclock)/(double)CLOCKS_PER_SEC;
			DTcount++;
		
		}	
		
		//if (get_draw())	calcRowCount();	
				
	
		if (channel==geometry) normaliseSource();
		else if (tube==geometry) normaliseSource();
		
		if (periodic!=geometry) normaliseSink();
	
		if (periodic==geometry)
		{
			analyseDataPeriodic();
		}
		else analyseData();
		
		
	}
	
	// temp
	//if (get_ratioOfDefects()>0.1)
	//{
	//			std::cout << "Blown up" << std::endl;
	//			end_simulation();
	//}
	

	check_for_end();

}

int CSimulation::initialise(std::string jobBatchFileLocation_)
{

	jobBatchFileLocation=jobBatchFileLocation_;
	
	// load parameters from file
	// iniread_GeneralParameters();
	
	// set variables from JobHeader.ini
	
	iniread_JobBatchFile();
	
	// make jobnum from seedtime and jobtag from jobbatch file	
	std::stringstream oss;
	oss << "job" << seedtime << "-" << jobtag; 
	jobnum=oss.str();
	std::cout << "JobNum: " << jobnum << std::endl << std::endl;
	
	// Get the number of processors in this system
int iCPU = omp_get_num_procs();

// Now set the number of threads
omp_set_num_threads(iCPU);

  std::cout << "Num CPUs: " << iCPU << std::endl << std::endl;

	// set up all simulation variables based on
	// parameters and job header
	
	configure_simulation();
	 
	// simulation variables
	t=1;
		
	// run initial functions
	
	initialise_files();
	
	if (channel==geometry) initialisePins();
	else if (tube==geometry) initialisePinsTube();
	else if (periodic==geometry)
	{
		systemWidth=12*b0+channelWidth+3*b0/2.0;
		systemLength=6*a0+channelLength+a0/2.0;
	
		firstPin.set_pos(-3*a0,-6*b0-channelOffset);
	}
	
	if (channel==geometry) initialiseVortices();
	else if (tube==geometry) initialiseVorticesTube();
	else if (periodic==geometry) initialiseVorticesPeriodic();
	
	//CParticle newVortex(10e-7,10e-7,0,0,5);
	//vorticesList.push_back(newVortex);
	
	initialiseChannelDisorder();
	
	// output all variables to jobheader as a record
	// and for use with the read run.
	iniwrite_jobheader();
	
	initialiseGlobal();
	
	return 0;
}


int CSimulation::initialiseWrite(
	int runtype_, int outputtype_, int geometry_, 
	double sourceBfield_, double sinkBfield_, double bathLength_,	double bathWidth_,
	double channelLength_,double channelWidth_, int simulation_time_, double temp_)
{
	// load parameters from file
	iniread_GeneralParameters();
	
	// set variables from command line arguments
	geometry=geometry_;
		
	sourceBfield=sourceBfield_;
	sinkBfield=sinkBfield_;
		
	channelLength=channelLength_*a0;
	channelWidth=channelWidth_*b0;
	bathLength=bathLength_*a0;
	bathWidth=bathWidth_*b0;
	
	simulation_time=simulation_time_;
	runtype=runtype_;
	outputtype=outputtype_;
	
	temp=temp_;  
	
	// set up all simulation variables based on
	// parameters and command line arguments
	configure_simulation();
	 
	// simulation variables
	t=1;
		
	// run initial functions
	
	initialise_files();
	
	if (channel==geometry) initialisePins();
	else if (tube==geometry) initialisePinsTube();
		
	if (channel==geometry) initialiseVortices();
	else if (tube==geometry) initialiseVorticesTube();
	
	initialiseChannelDisorder();
		
	// output all variables to jobheader
	iniwrite_jobheader();
	
	initialiseGlobal();

	return 0;
		
	
}

int CSimulation::initialiseRead(int runtype_, int starting_time_step_, bool triangulateReadRun_, std::string jobnum_)
{
	runtype=runtype_;
	jobnum=jobnum_;
	triangulateReadRun=triangulateReadRun_;
	starting_time_step=starting_time_step_;
	
	std::cout << "Run type: " << runtype << std::endl;
	std::cout << "Job Number: " << jobnum << std::endl;
	std::cout << "Triangulate: " << triangulateReadRun << std::endl;
	std::cout << "starting time step: " << starting_time_step << std::endl;
	
	iniread_JobHeader();
	
	read_PinsList();
		
	t=1;	
	
	initialiseGlobal();
	
	return 0;
	
}

int CSimulation::initialiseGlobal()
{
	vortexSize=0.2*get_a0();
	
	A=2*kB*temp/eta;
	
	simulation_initialised=true;
	
	std::cout << "Simulation initialised.\n\n";
	
	return 0;
}

std::list<CParticle>* CSimulation::get_vorticesList()
{
	return &vorticesList;
}

std::list<CParticle>* CSimulation::get_delVortexList()
{
	return &delVortexList;
}

std::list<CParticle>* CSimulation::get_pinsList()
{
	return &pinsList;
}

std::list<CDelLine>* CSimulation::get_delLinesList()
{
	return &delLinesList;
}

std::vector<CPin>* CSimulation::get_disorderVector()
{
	return &disorderVector;
}

std::vector<CDelLine>* CSimulation::get_rowCountLinesVector()
{
	return &rowCountLinesVector;
}

std::vector<CRowCount>* CSimulation::get_rowCount()
{
	return &rowCount;
}

int CSimulation::get_t()
{
	return t;
}

int CSimulation::get_simulation_time()
{
	return simulation_time;
}


CParticle CSimulation::get_firstPin() const
{
	return firstPin;
}

bool CSimulation::is_running() const 
{
	return running;
}


bool CSimulation::is_initialised() const
{
    return simulation_initialised;
}

void CSimulation::check_for_start()
{
	if (is_initialised() && false==running) running=true;	
}

void CSimulation::check_for_end()
{
	if (true==running && t>simulation_time) running=false;	
}

void CSimulation::initialise_files()
{
	// make new directory for data
	std::cout << "Initialising files..." << std::endl;
	
	std::string dirStr;
	std::string fileStr;
	
	std::ostringstream dirOss;
	std::ostringstream fileOss;
	
	dirOss << jobnum;
	dirStr = dirOss.str();
	
	#if defined (__WINDOWS__)
		CreateDirectory (dirStr.c_str(), NULL);
	#else
		mkdir(dirStr.c_str(),0755);	
	#endif
	
	
	// position data
	fileOss.str("");
	fileOss << dirOss.str() << "//posdata.txt";
	fileStr= fileOss.str();
	
	
	posfile.open(fileStr.c_str());
	posfile.precision(5);
	
	// density results
	
	fileOss.str("");
	fileOss << dirOss.str() << "//densitydata.txt";
	fileStr= fileOss.str();
	
	densityfile.open(fileStr.c_str());
	densityfile.precision(5);
	
	// density results
	
	fileOss.str("");
	fileOss << dirOss.str() << "//newVortexData.txt";
	fileStr= fileOss.str();
	
	newVortexfile.open(fileStr.c_str());
	newVortexfile.precision(5);
	
	
	
	// a0 results
	
	fileOss.str("");
	fileOss << dirOss.str() << "//a0data.txt";
	fileStr= fileOss.str();
	
	
	
	a0file.open(fileStr.c_str());
	a0file.precision(5);
	//output a0 file header
	/*a0file << std::setw(15) << "Time";
	for (int i=0; i<=numa0Bins-1;i++ ) {  // USE THIS IF A0 DATA OUTPUT IN AVERGAED BINS
	a0file <<std::setw(15) << (urectx1-urectx0)/numa0Bins*(i+.5);
	}	
	a0file << endl;	*/
	
	// averaged line lengths results
	
	fileOss.str("");
	fileOss << dirOss.str() << "//avlinelengthdata.txt";
	fileStr= fileOss.str();
	
	
	
	avlinelengthfile.open(fileStr.c_str());
	avlinelengthfile.precision(5);
	
	
	
	// b0 results
	
	fileOss.str("");
	fileOss << dirOss.str() << "//b0data.txt";
	fileStr= fileOss.str();
	
	
	
	b0file.open(fileStr.c_str());
	b0file.precision(5);
	
	
	// dislocation results
	fileOss.str("");
	fileOss << dirOss.str() << "//disdata.txt";
	fileStr= fileOss.str();
	
	
	disfile.open(fileStr.c_str());
	disfile.precision(5);
	disfile << "Modified output range (not whole channel)" << std::endl;
	
	// raw velocity results
	fileOss.str("");
	fileOss << dirOss.str() << "//rawvdata.txt";
	fileStr= fileOss.str();
	
	
	rawvfile.open(fileStr.c_str());
	rawvfile.precision(5);
	
	
	
	
	// v(x) results
	fileOss.str("");
	fileOss << dirOss.str() << "//vxdata.txt";
	fileStr= fileOss.str();
	
	
	vxfile.open(fileStr.c_str());
	vxfile.precision(5);
	
	//vfile << std::setw(15) << "Time";
	/*for (int i=0; i<=numa0Bins-1;i++ ) {
	vfile <<std::setw(15) << (urectx1-urectx0)/numa0Bins*(i+.5);
	}	*/
	//vfile << endl;	
	
	// v(y) results
	fileOss.str("");
	fileOss << dirOss.str() << "//vydata.txt";
	fileStr= fileOss.str();
	
	
	vyfile.open(fileStr.c_str());
	vyfile.precision(5);
	
	/*for (int i=0; i<=numvyBins-1;i++ ) {
	vfile <<std::setw(15) << (urecty1-urecty0)/numvyBins*(i+.5);
	}	
	vfile << endl;	
	*/
	
	// file needed for displaying gui data with read program
	fileOss.str("");
	fileOss << dirOss.str() << "//jobheader.ini";
	fileStr= fileOss.str();
	
	
	guiheader.open(fileStr.c_str());
	guiheader.precision(15);
	
	fileOss.str("");
	fileOss << dirOss.str() << "//guidata.txt";
	fileStr= fileOss.str();
	
	
	guifile.open(fileStr.c_str());
	guifile.precision(5);
	
	
	// velocity field data
	fileOss.str("");
	fileOss << dirOss.str() << "//velfielddata.txt";
	fileStr= fileOss.str();
	
	
	velfieldfile.open(fileStr.c_str());
	velfieldfile.precision(5);
	
	// velocity field data
	fileOss.str("");
	fileOss << dirOss.str() << "//vfieldAveraged.txt";
	fileStr= fileOss.str();
	
	
	vfieldAvfile.open(fileStr.c_str());
	vfieldAvfile.precision(5);
	
	// averageda0data.csv
	fileOss.str("");
	fileOss << dirOss.str() << "//averageda0data.csv";
	fileStr= fileOss.str();
	
	
	averageda0data.open(fileStr.c_str());
	averageda0data.precision(5);
	
	// averagedvxdata.csv
	fileOss.str("");
	fileOss << dirOss.str() << "//averagedvxdata.csv";
	fileStr= fileOss.str();
	
	
	averagedvxdata.open(fileStr.c_str());
	averagedvxdata.precision(5);
	
	// averagedBfielddata.csv
	fileOss.str("");
	fileOss << dirOss.str() << "//averagedBfielddata.csv";
	fileStr= fileOss.str();
	
	
	averagedBfielddata.open(fileStr.c_str());
	averagedBfielddata.precision(5);
	
	// Jyy.csv
	fileOss.str("");
	fileOss << dirOss.str() << "//Jyy.dat";
	fileStr= fileOss.str();
	
	
	Jyydata.open(fileStr.c_str());
	Jyydata.precision(5);
	//Jyydata << "{";
	
	// Jxx.csv
	fileOss.str("");
	fileOss << dirOss.str() << "//Jxx.dat";
	fileStr= fileOss.str();
	
	
	Jxxdata.open(fileStr.c_str());
	Jxxdata.precision(5);
	//Jyydata << "{";
	
	// Jxy.csv
	fileOss.str("");
	fileOss << dirOss.str() << "//Jxy.dat";
	fileStr= fileOss.str();
	
	
	Jxydata.open(fileStr.c_str());
	Jxydata.precision(5);
	
	// Jyx.csv
	fileOss.str("");
	fileOss << dirOss.str() << "//Jyx.dat";
	fileStr= fileOss.str();
	
	
	Jyxdata.open(fileStr.c_str());
	Jyxdata.precision(5);
	
	
	
	
	// mathematicaGuiFile.csv
	fileOss.str("");
	fileOss << dirOss.str() << "//mathematicaGuiFile.dat";
	fileStr= fileOss.str();
	
	
	mathematicaGuiFile.open(fileStr.c_str());
	mathematicaGuiFile.precision(5);
	//Jyydata << "{";
	
	// pin positions file
	fileOss.str("");
	fileOss << dirOss.str() << "//pinsdata.txt";
	fileStr= fileOss.str();
	
	
	pinsfile.open(fileStr.c_str());
	pinsfile.precision(5);
  
  // temp
  
  fileOss.str("");
	fileOss << dirOss.str() << "//M2.txt";
	fileStr= fileOss.str();
	
  M2file.open(fileStr.c_str());
	M2file.precision(5);
  
  ///////////////////
  
  
  // forces data
	fileOss.str("");
	fileOss << dirOss.str() << "//forcesdata.txt";
	fileStr= fileOss.str();
	
	
	forcesfile.open(fileStr.c_str());
	forcesfile.precision(5);
	
	
	// final averages data
	fileOss.str("");
	fileOss << dirOss.str() << "//averagesdata.txt";
	fileStr= fileOss.str();
	
	
	avfile.open(fileStr.c_str());
	avfile.precision(5);
	
	// nearest neighbour line ends
	
	fileOss.str("");
	fileOss << dirOss.str() << "//a0lineends.txt";
	fileStr= fileOss.str();
	
	a0lineendsfile.open(fileStr.c_str());
	a0lineendsfile.precision(5);

	// nearest neighbour line ends
	
	fileOss.str("");
	fileOss << dirOss.str() << "//Bfield.txt";
	fileStr= fileOss.str();
	
	Bfieldfile.open(fileStr.c_str());
	Bfieldfile.precision(5);
	
	// trajectories.txt
	fileOss.str("");
	fileOss << dirOss.str() << "//trajectories.txt";
	fileStr= fileOss.str();
	
	
	trajfile.open(fileStr.c_str());
	trajfile.precision(5);
  
  // maxvel.txt
	fileOss.str("");
	fileOss << dirOss.str() << "//maxvel.txt";
	fileStr= fileOss.str();
	
	
	maxvelfile.open(fileStr.c_str());
	maxvelfile.precision(5);
  
  
    
	std::cout << "   Files initialised.\n\n";
}


void CSimulation::clean_up()
{
	
	b0file.close();
	a0file.close();
	vxfile.close();
	vyfile.close();
	posfile.close();
	disfile.close();
	guifile.close();
	guiheader.close();
	avlinelengthfile.close();
	densityfile.close();
	velfieldfile.close();
	newVortexfile.close();
	averageda0data.close();
	averagedvxdata.close();
	Jyydata.close();
	Jxxdata.close();
	Jxydata.close();
	Jyxdata.close();
	pinsfile.close();
	rawvfile.close();
	averagedBfielddata.close();
	mathematicaGuiFile.close();
	forcesfile.close();
	avfile.close();
	a0lineendsfile.close();
	Bfieldfile.close();
	vfieldAvfile.close();
	trajfile.close();
	maxvelfile.close();
	
	//temp
	M2file.close();
	///////////////
	
	endTime = clock();
	
	std::cout << "Run Time: " << (endTime-startTime)/(double)CLOCKS_PER_SEC << std::endl;
	
	std::cout << "Total DTtime: " << DTtime << std::endl;
	std::cout << "Total ftime: " << ftime << std::endl;
	
	
	std::cout << "DTtime: " << DTtime/(double)DTcount << " per iteration (" << DTcount << ")" << std::endl;
	std::cout << "ftime: " << ftime/(double)fcount << " per iteration (" << fcount << ")"<< std::endl;
	
}



void CSimulation::initialisePins() {
	//double offset=channelOffset;//channelWidth/2.0;
	
	std::cout << "Initialising pins..." << std::endl;
	
	double locala0=a0;
	double localb0=b0;
	double xPos;
	
	systemWidth=12*localb0+bathWidth+3*localb0/2.0;
	systemLength=6*locala0+2*bathLength+channelLength+locala0/2.0;
	
	firstPin.set_pos(-3*a0,-6*localb0-channelOffset);
	
	double yPos=firstPin.get_y();
	
	//std::cout << "Bottom Limit: " << yPos << std::endl; 
	//std::cout << "Top Limit: " << bathWidth+6*localb0-channelOffset << std::endl; 
	
	while (yPos<bathWidth+6*localb0-channelOffset-0.1*b0)
	{
		xPos=firstPin.get_x();
	
		while (xPos<bathLength+channelLength+bathLength+3*locala0)
		{
	
			CParticle newPin;
			newPin.set_pos(xPos,yPos+localb0/2.0);
			pinsList.push_back(newPin);
	
			newPin.set_pos(xPos+locala0/2.0,yPos+3*localb0/2.0);
			pinsList.push_back(newPin);
			
			xPos=xPos+locala0;
	
		}
	
		yPos=yPos+2*localb0;
		std::cout << "   yPos: " << yPos << std::endl;
	}
	
	//etch source, sink && channel
	bool removed;
	std::list<CParticle>::iterator p= pinsList.begin();
	
	while (p!=pinsList.end())
	{
	
		removed=false;
		//etch source
		if (  p->get_x() > etchsourcex0 && p->get_x() < etchsourcex1
			&& p->get_y() > etchsourcey0 && p->get_y() < etchsourcey1 )
		{
			p=pinsList.erase(p);
			removed=true;
	
		}
		else if (  p->get_x() > etchchannelx0 && p->get_x() < etchchannelx1
			&& p->get_y() > etchchannely0 && p->get_y() < etchchannely1 )
		{
			p=pinsList.erase(p);
			removed=true;
		
		}
		else if (  p->get_x() > etchsinkx0 && p->get_x() < etchsinkx1
			&& p->get_y() > etchsinky0 && p->get_y() < etchsinky1 )
		{
			p=pinsList.erase(p);
			removed=true;
		}
	
	
		if (removed==false) { ++p; }
	
	
	}
	
	std::cout << "   initialisePins() created " << pinsList.size() << " CE vortices." << std::endl <<std::endl;
	
}

void CSimulation::iniwrite_jobheader()
{
	guiheader << "[Overview]\n"
	<< "jobnum=" << jobnum << std::endl
	<< std::endl;
	
	guiheader <<"[ReadableBatchOptions]\n"
	<< "runtype=0" << std::endl
	<< "geometry=";
	if(channel==geometry) guiheader << "channel";
	else if(tube==geometry) guiheader << "tube";
	guiheader << std::endl
	<< "sourceBfield="<< sourceBfield << std::endl
	<< "sinkBfield="<< sinkBfield << std::endl
	<< "bathLength="<< bathLength/a0 << std::endl
	<< "bathWidth="<< bathWidth/b0 << std::endl
	<< "channelLength="<< channelLength/a0 << std::endl
	<< "channelWidth="<< channelWidth/b0 << std::endl
	<< "simulationTime="<< simulation_time << std::endl
	<< "temp=" << temp << std::endl
	<< "lorentzForce=" << lorentzForce << std::endl
	<< std::endl;


	guiheader <<"[BatchOptions]\n"
	<< "runtype=0" << std::endl
	<< "geometry="<< geometry << std::endl
	<< "sourceBfield="<< sourceBfield << std::endl
	<< "sinkBfield="<< sinkBfield << std::endl
	<< "bathLength="<< bathLength << std::endl
	<< "bathWidth="<< bathWidth << std::endl
	<< "channelLength="<< channelLength << std::endl
	<< "channelWidth="<< channelWidth << std::endl
	<< "simulationTime="<< simulation_time << std::endl
	<< "temp=" << temp << std::endl
	<< "LorentzForce=" << lorentzForce << std::endl
	
	<< std::endl;
	
	guiheader << "[Job]\n"
	<< "jobtag=" << jobtag << std::endl
	<< std::endl;


	guiheader <<"[ConfigVariables]\n"
	<< "channelOffset=" << channelOffset <<std::endl
	<< "etchsourcex0="<< etchsourcex0 << std::endl
	<< "etchsourcey0="<< etchsourcey0 << std::endl
	<< "etchsourcex1="<< etchsourcex1 << std::endl
	<< "etchsourcey1="<< etchsourcey1 << std::endl
	
	<< "etchsinkx0="<< etchsinkx0 << std::endl
	<< "etchsinky0="<< etchsinky0 << std::endl
	<< "etchsinkx1="<< etchsinkx1 << std::endl
	<< "etchsinky1="<< etchsinky1 << std::endl
	
	<< "etchchannelx0="<< etchchannelx0 << std::endl
	<< "etchchannely0="<< etchchannely0 << std::endl
	<< "etchchannelx1="<< etchchannelx1 << std::endl
	<< "etchchannely1="<< etchchannely1 << std::endl
	
	<< "removesourcex=" << removesourcex << std::endl
	<< "removesinkx=" << removesinkx << std::endl
	<< "removesourcey0=" << removesourcey0 << std::endl
	<< "removesourcey1=" << removesourcey1 << std::endl
	
	<< "removechannelx0=" << removechannelx0 << std::endl
	<< "removechannelx1=" << removechannelx1 << std::endl
	
	<< "removetopchannely=" << removetopchannely << std::endl
	<< "removebottomchannely=" << removebottomchannely << std::endl
	
	<< "urectx0=" << urectx0 << std::endl
	<< "urecty0=" << urecty0 << std::endl
	<< "urectx1=" << urectx1 << std::endl
	<< "urecty1=" << urecty1 << std::endl
	
	<< "bulkx0=" << bulkx0 << std::endl
	<< "bulky0=" << bulky0 << std::endl
	<< "bulkx1=" << bulkx1 << std::endl
	<< "bulky1=" << bulky1 << std::endl
	
	<< "dislocationx0=" << dislocationx0 << std::endl
	<< "dislocationy0=" << dislocationy0 << std::endl
	<< "dislocationx1=" << dislocationx1 << std::endl
	<< "dislocationy1=" << dislocationy1 << std::endl
	
	<< "numBins=" << numBins << std::endl
	<< "f0=" << f0 << std::endl
	
	<< "sourceDensity=" << sourceDensity << std::endl
	<< "sinkDensity=" << sinkDensity << std::endl
	<< "channelDensity=" << channelDensity << std::endl
	<< std::endl;
		
	guiheader << "[DrawingVariables]\n"
	<< "firstPinx=" << firstPin.get_x() << std::endl
	<< "firstPiny=" << firstPin.get_y() << std::endl
	<< "systemLength=" << systemLength << std::endl
	<< "systemWidth=" << systemWidth << std::endl
	<< std::endl;

	guiheader << "[GeneralParameters]\n"
	<< "a0=" << a0 << std::endl
	<< "binSize=" << binsize << std::endl
	<< "vfieldBinSize=" << vfieldBinSize << std::endl
	<< "cellSize=" << cellSize << std::endl
	<< "pi=" << pi << std::endl 
	<< "Phi=" << Phi << std::endl 
	<< "forceRange=" << forceRange << std::endl 
	<< "eta=" << eta << std::endl 
	<< "kB=" << kB << std::endl 
	<< "mu0=" << mu0 << std::endl 
	<< "lambda=" << lambda << std::endl 
	<< "Ap=" << Ap << std::endl 
	<< "dt=" << dt << std::endl 
	<< "tau=" << tau << std::endl 
	<< "drawInterval=" << drawInterval << std::endl 
	<< "triangulationInterval=" << triangulationInterval << std::endl
	<< "thermostat=" << thermostat << std::endl
	<< "disorderDensity=" << disorderDensity << std::endl
	<< "disorderStrength=" << disorderStrength << std::endl
	<< "disorderRange=" << disorderRange << std::endl
	<< std::endl;
	
	guiheader << "[meshworks]\n"
	<< "version=" << version.get_versionStr() << std::endl
	<< std::endl;
 
  
}


void CSimulation::analyseData() {
	
	calculateBinnedBfield();
	
	calculateBinnedvelocityProfile();
				
	calculateAvVel();
	
	calculateRatioOfDefects();
	
	outputFinalVortexPositions();
	
	//outputForces();
	
	if (true==calcTrajectories) updateTrajectories();
	
	outputAverages();
			
	// Output the pinsList	
	if(false==outputpins) {
		outputpins=true;
		for (std::list<CParticle>::iterator p = pinsList.begin();
					p!=pinsList.end();++p) {
			pinsfile << std::setw(15) << p->get_x() << std::setw(15) << p->get_y() << std::endl;
		
		}
	
	}	
	
	
	
	
	// output position data
	if (0==t%triangulationInterval)
	{
		
		
		
		// vorticesList.size() should be the same as delVortexList.size() with the ghost particles
		guifile << "   " <<  "timestep: " << t << "   NumVortices: ";
		int numVortices=0;
		for (std::list<CParticle>::iterator p = delVortexList.begin();
			p != delVortexList.end(); ++p)
		{
			if (p->get_ghost()!=true)
			{
				numVortices++;
			}				 
		}
		 guifile << numVortices << std::endl;
		
		for (std::list<CParticle>::iterator p = delVortexList.begin();
			p != delVortexList.end(); ++p)
		{
			if (p->get_ghost()!=true)
			{
				guifile << std::setw(20) << p->get_x() << std::setw(20) << p->get_y() << std::setw(20) << p->get_coord_num() << std::setw(20) << p->get_a() << std::endl;
			}				 
		}
	}
	else guifile << "   " <<  "timestep: " << t << "   NumVortices: 0" << std::endl;

				
	static std::vector<CBin> vxBinVectorSum (numBins);
	static std::vector<CBin> densityBinVectorSum (numBins);
	
	std::ostringstream oss;
	oss.precision(5);
	oss.str("");
	
	std::vector<CBin> vxBinVector (numBins);
	std::vector<CBin> densityBinVector (numBins);
	
	int bin;
	
	
	// calculate the v(x) velocity profile  ( using CBin class)
	for (std::list<CParticle>::iterator p = vorticesList.begin();
		p!=vorticesList.end();++p) 
	{
		if (p->get_x() >= 0 && p->get_x() <= 2*bathLength+channelLength 
			&& p->get_y() >= 0 && p->get_y() <= channelWidth)
		{
			//std::cout << "bin" << endl;
			bin = (int)floor((p->get_x()+binsize/2.0)* (numBins/(urectx1-urectx0)));
			//vxbin = bin;   // for vxfile
			vxBinVector[bin].set_val(p->get_velx());  //for vxfile
	
		}
	}
	

	
	
	vxfile << "timestep: " << t << std::endl;
	int bincount=0;
	
	for (std::vector<CBin>::iterator p = vxBinVector.begin();
		p!= vxBinVector.end(); ++p )
	{
		vxfile<< std::setw(15) << binsize/2.0+urectx0+bincount*binsize  << std::setw(15) << p->get_val() << std::endl;
		bincount++;
	
		vxBinVectorSum[p-vxBinVector.begin()].set_val(p->get_val());
	
	}
	
	vxfile  << std::endl;
	
	
	
	// CALCULATION && FILE OUTPUT OF A0 USING AVERAGED BIN METHOD
	
	if (0==t%triangulationInterval)
	{
		for (std::list<CParticle>::iterator p = delVortexList.begin();
			p!=delVortexList.end();++p)
		{
			if (""==thermostat)
			{
				if (p->get_x() < 0 || p->get_x() >= 2*bathLength+channelLength 
					|| p->get_y() < 0 || p->get_y() > channelWidth) continue;
				
				bin = (int)floor((p->get_x()+binsize/2.0)* (numBins/(urectx1-urectx0)));
				densityBinVector[bin].set_val(p->get_a());
				
			}
			else
			{
				if (p->get_x() < bathLength || p->get_x() >= bathLength+channelLength 
					|| p->get_y() < 0 || p->get_y() > channelWidth) continue;
				
				bin = (int)floor((p->get_x()+binsize/2.0)* (numBins/(urectx1-urectx0)));
				densityBinVector[bin].set_val(p->get_a());
				
			}
		
		}
		
		// calculate averaged a0 data from average of all lines connected to a vortex
		
		bincount=0;
	
		densityfile << "timestep: " << t << std::endl;
	
	
		for (std::vector<CBin>::iterator p = densityBinVector.begin();
			p!= densityBinVector.end(); ++p )
		{
				densityfile<< std::setw(15) << binsize/2.0+urectx0+bincount*binsize  << std::setw(15) << p->get_val() << std::setw(15) << p->get_count() << std::endl;
				bincount++;
				densityBinVectorSum[p-densityBinVector.begin()].set_val(p->get_val());
			
			
		}
		
		densityfile  << std::endl;
	
	
		// OUTPUT A0 DATA FOR EACH VORTEX SEPARATELY
		avlinelengthfile << "Time: " << t << std::endl;
		
		for (std::list<CParticle>::iterator p = delVortexList.begin();
			p!= delVortexList.end(); ++p )
		{
			if ( p->get_y() >= bulky0 && p->get_y() <= bulky1)
			{
				avlinelengthfile<< std::setw(15) << p->get_x() << std::setw(15) << p->get_a() << std::endl;
			}
		
	
		}
	
		avlinelengthfile << std::endl;
	
		for (std::vector<CBin>::iterator p =densityBinVector.begin();
			p!= densityBinVector.end(); ++p )
		{
			double Beff=2*Phi/(sqrt((double)3)*p->get_val()*p->get_val());		
			
			if (boost::math::isinf((double)(Beff))) oss << std::setw(10) << "-";
			else oss<<  std::setw(10) << Beff;
		
		
			//std::cout << Beff << std::endl;
		
		
		}
		
		analysisDataStr=oss.str();
	
	}
	
	
	if (t==simulation_time)
	{
		vxfile << "Time average of binned vx values" << std::endl;
		bincount=0;
		
		for (std::vector<CBin>::iterator p = vxBinVectorSum.begin();
			p!= vxBinVectorSum.end(); ++p )
		{
	
			vxfile<< std::setw(15) << binsize/2.0+urectx0+bincount*binsize  << std::setw(15) << p->get_val() << std::setw(15) << p->get_count() <<  std::endl;
			bincount++;
	
		}
	
		vxfile  << std::endl;
	
		densityfile << "Time average of binned density values" << std::endl;
		bincount=0;
		
		for (std::vector<CBin>::iterator p = densityBinVectorSum.begin();
			p!= densityBinVectorSum.end(); ++p )
		{
	
			densityfile<< std::setw(15) << binsize/2.0+urectx0+bincount*binsize  << std::setw(15) << p->get_val() << std::setw(15) << p->get_count() <<  std::endl;
			bincount++;
	
		}
		
		densityfile  << std::endl;
	
		// output in csv format
	
		bincount=0;
		for (std::vector<CBin>::iterator p = vxBinVectorSum.begin();
			p!= vxBinVectorSum.end(); ++p )
		{
			averagedvxdata<<  binsize/2.0+urectx0+bincount*binsize  << "," << p->get_val() << std::endl;
			bincount++;
			
		}
		
		bincount=0;
		for (std::vector<CBin>::iterator p = densityBinVectorSum.begin();
		p!= densityBinVectorSum.end(); ++p )
		{
			averageda0data<<  binsize/2.0+urectx0+bincount*binsize  << "," << p->get_val() << std::endl;
			bincount++;
		
		}
	
	}
	
	/*
	vxfile << "  Time:"<< t << std::endl;
	for (list<CParticle>::iterator p = vorticesList.begin();
	p!=vorticesList.end();++p) {
	if (p->get_x() >= urectx0 && p->get_x() <= urectx1) {
	vxfile << std::setw(15) << p->get_x()  << std::setw(15) << p->get_y() << std::setw(15) << p->get_velx() << std::setw(15) << p->get_vely() <<std::endl;;
	
	
	}
	}
	vxfile << std::endl;
	*/
	
	/*
	//ux
	for (list<CParticle>::iterator p = vorticesList.begin();
	p!=vorticesList.end();++p) {
	if (p->get_x() >= urectx0 && p->get_x() <= urectx1
	&& p->get_y() >= urecty0 && p->get_y() <= urecty1) {
	//std::cout << "bin" << std::endl;
	double adjustedx = p->get_x() - urectx0;
	vbin = (int)floor(adjustedx * (numa0Bins/(urectx1-urectx0)));
	vBinVector[vbin].set_val(p->get_velx());
	
	}
	}
	vfile << std::setw(15) << t;
	for (std::vector<CBin>::iterator p = vBinVector.begin();
	p!= vBinVector.end(); ++p ) {
	vfile << std::setw(15) << p->get_val();
	
	}
	vfile << std::endl;
	
	//uy
	for (list<CParticle>::iterator p = vorticesList.begin();
	p!=vorticesList.end();++p) {
	if (p->get_x() >= urectx0+(urectx1-urectx0)/2.0-latticeSpacing && p->get_x() <= urectx0+(urectx1-urectx0)/2.0+latticeSpacing
	&& p->get_y() >= urecty0 && p->get_y() <= urecty1) {
	//std::cout << "bin" << std::endl;
	double adjustedy = p->get_y() - urecty0;
	vybin = (int)floor(adjustedy * (numvyBins/(urecty1-urecty0)));
	vyBinVector[vybin].set_val(p->get_velx());
	
	}
	}
	vyfile << std::setw(15) << t;
	for (std::vector<CBin>::iterator p = vyBinVector.begin();
	p!= vyBinVector.end(); ++p ) {
	vyfile << std::setw(15) << p->get_val();
	
	}
	vyfile << std::endl;
	
	
	*/
	
	// output a0 && bo data to file
	
	// This result comes from actual line lengths plotted at the mid point of the
	// line
	
	
	
	if (0==t%triangulationInterval) 
	{  
		a0file << "  time:" << t << " " << std::endl;
		a0lineendsfile << "  time:" << t << " " << std::endl;
		b0file << "  time:" << t << " " << std::endl;
		
		for (std::list<CDelLine>::iterator p = delLinesList.begin();
			p!=delLinesList.end(); ++p)
		{
			double midy = (p->get_y1() + p->get_y2())/2.0;
		
			if ( midy <= bulky0 || midy >= bulky1)
				continue;
			
				
			//std::cout << "a0scaled: " << graphy1-a0scaling*p->get_val() << std::endl;
	
			// find line length
			double linelength=sqrt((double) (p->get_x1()-p->get_x2())*(p->get_x1()-p->get_x2())
				+ (p->get_y1()-p->get_y2())*(p->get_y1()-p->get_y2()));
			
			double rowspacing= fabs(p->get_y2()-p->get_y1());												
	
	
	
			// draw horizontal lines as different colours to diagonal
			double ydiff=fabs(p->get_y2()-p->get_y1());
			double xdiff=fabs(p->get_x2()-p->get_x1());
			double ybyx;
			if (0==xdiff) ybyx=100000000;
			else ybyx=ydiff/xdiff;
			
			
			if (fabs(atan(ybyx))<pi/6.0) // horizontal
			{ 
				a0file<< std::setw(15) << (p->get_x1() +p->get_x2())/2.0 << std::setw(15) << linelength << "   horizontal a0"<< std::endl;
				
			}
			else
			{
				a0file<< std::setw(15) << (p->get_x1() +p->get_x2())/2.0 << std::setw(15) << linelength << "  diagonal a0" << std::endl;
	
			}
			a0lineendsfile << p->get_x1() << "   " << p->get_y1() << "  " << p->get_x2() << "   " << p->get_y2() << std::endl;
	
			if (rowspacing > linelength/4.0)
			{  
				// calculate b0 from a0 lines only 
				b0file << std::setw(15) << (p->get_x1() +p->get_x2())/2.0 << std::setw(15) << rowspacing << std::endl;
	
			}
		
			
		}
		
		a0file << std::endl;
		a0lineendsfile << std::endl;
	
	}
	

		
	// output dislocation data
	
	
	if (t%25==0)
	{ // set to 50 after test
		std::vector<CParticle> unsortedVector;
		disfile << std::setw(10) << t;
	
		for (std::list<CParticle>::iterator p = delVortexList.begin();
			p != delVortexList.end(); ++p)
		{
			if (p->get_x() >= dislocationx0 && p->get_x() <= dislocationx1
				&& p->get_y() >= dislocationy0 && p->get_y() <= dislocationy1)
			{
	
				if (p->get_coord_num()== 5)
				{
					// add to unsorted std::vector
					CParticle newVector;
					newVector.set_pos(p->get_x(),p->get_y());
					unsortedVector.push_back(newVector);
				}
			}
		}
		//sort
		sort (unsortedVector.begin(),unsortedVector.end(),xSort);
		//output sortedvector
		for (std::vector<CParticle>::iterator p=unsortedVector.begin();
			p!=unsortedVector.end(); ++p )
		{
			disfile << std::setw(15) << p->get_x() << std::setw(15) << p->get_y();
				
		}
		
		disfile << std::endl;
	}
		
		
	// output dislocation path data
	/*
	int pathnum=1;
	for (std::vector< std::vector<CTemporalCoord> >::iterator iter_ii = pathsVector.begin();
	iter_ii != pathsVector.end(); ++iter_ii) {
	if (iter_ii->size()>500) {		
	disfile << std::setw(3) << "path: " << std::setw(5) << pathnum << std::endl; 
	for (std::vector<CTemporalCoord>::iterator iter_jj= (*iter_ii).begin();
	iter_jj!=(*iter_ii).end(); ++iter_jj) {
	//disfile << "  (" << std::setw(7)<< iter_jj->get_x() << "," << std::setw(7) << iter_jj->get_y() << "," << iter_jj->get_time() <<")";	
	disfile << std::setw(7)<< iter_jj->get_x() <<  std::setw(15) << iter_jj->get_y() << std::setw(15) << iter_jj->get_time() << std::endl;	
	}	
	disfile << std::endl;
	pathnum++;
	}
	}
	*/
	
	
	
	// output velocity field data
	
	
	/*if (outputvelfield==true)
	{
		velfieldfile << "Time: " << t << std::endl;
		//velfieldfile.setf(ios::fixed);
		//velfieldfile.precision(5);
		
		velfieldfile << "{";
		
		for(std::list<CParticle>::iterator p = vorticesList.begin();
			p != vorticesList.end(); ++p)
		{
		
			velfieldfile << "{{" << p->get_x() << "," << p->get_y() << "},{"
				<< p->get_velx() << "," << p->get_vely() << "}},";
		
		}
		
		velfieldfile << "}"<< std::endl;
		
	}*/
	
	
	
	if (0==t%25)
	{ 
		// Output Jyy as list for mathematica
		//Jyydata << "{";
		for (std::list<CParticle>::iterator p = delVortexList.begin();
			p!=delVortexList.end(); ++p)
		{
		
			Jyydata << p->get_x()/a0 <<" " << p->get_y()/a0 << " " <<p->get_Jyy() <<" " << p->get_coord_num();
			Jxxdata << p->get_x()/a0 <<" " << p->get_y()/a0 << " " <<p->get_Jxx() <<" " << p->get_coord_num();
			Jxydata << p->get_x()/a0 <<" " << p->get_y()/a0 << " " <<p->get_Jxy() <<" " << p->get_coord_num();
			Jyxdata << p->get_x()/a0 <<" " << p->get_y()/a0 << " " <<p->get_Jyx() <<" " << p->get_coord_num();
			
			//if (p==vorticesList.end()) Jyydata << "end";
			//if (p!=vorticesList.end()) Jyydata << ",";
			
			if ( std::distance(p,delVortexList.end()) != 1 )
			{
				Jyydata << "  ";
				Jxxdata << "  ";
				Jxydata << "  ";
				Jyxdata << "  ";
			}
			
		}
		//Jyydata << "}";
		
		
		if (t!=simulation_time)
		{
			Jyydata << std::endl; 
			Jxxdata << std::endl; 
			Jxydata << std::endl; 
			Jyxdata << std::endl; 
		}
		
		
	}
		  
		

		
}

double CSimulation::get_a0() const 
{
	return a0;
}

double CSimulation::get_b0() const
{
	return b0;
}

int CSimulation::get_geometry() const 
{
	return geometry;
}

double CSimulation::get_channelLength() const 
{
	return channelLength;
}

double CSimulation::get_channelWidth() const 
{
	return channelWidth;
}

double CSimulation::get_bathLength() const 
{
	return bathLength;
}


double CSimulation::get_vortexSize() const 
{
	return vortexSize;
}

	
double CSimulation::get_systemLength() const 
{
	return systemLength;
}

double CSimulation::get_systemWidth() const 
{
	return systemWidth;
}

bool CSimulation::get_draw() const
{
	// Only let system draw at given draw intervals
	// Only let system draw if runtype is read or write with gui
	if (0==t%drawInterval && (0==runtype || 2==runtype)) return true;
	return false;
}


void CSimulation::normaliseSource()
{
	static int lastadded=0;
	double Beff= calcSourceB();
	
	
	
	
	// calculate zone densities
	int sourceCount=0;
	int sinkCount=0;
	
	// count densities
	for (std::list<CParticle>::iterator p = vorticesList.begin();
		p != vorticesList.end(); ++p) {
		if (p->get_x() < bathLength && (p->get_y()<0 || p->get_y()>channelWidth))
			      sourceCount++;
		if (p->get_x() > bathLength+channelLength && 
			     (p->get_y()<0 || p->get_y()>channelWidth)) sinkCount++;
	}
	
	if (Beff<sourceBfield && t-lastadded>=10) { // add a source vortex - at most every 10 steps
		lastadded=t;
	newVortexfile << std::setw(10) << t;
		
		
			CParticle newVortex;
			
			double xval = (2*a0)*(rand() % 1000)/1000.0;
			double yval = bathWidth*(rand() % 1000)/1000.0;
			xval=xval+a0/2.0;
			// choose top || bottom
			/*if (rand()%2==0)
			{
				// top
				yval=yval-channelOffset;
				
			}
			else {
				//bottom
				yval=yval+channelWidth;
			}*/
			
			
			
			newVortex.set_pos
					( xval,yval);
			
			vorticesList.push_back(newVortex);
			
			//output newVortex added data
		
			
		
		newVortexfile << std::setw(10) << 1 << std::endl;
		
	}
	
	
	
	
}
			




void CSimulation::normaliseSink() {
	// This routine calculates the effective B field of the source (not in the wings)
	// It then removes sink vortices from the wings until the density is low enough.
	double Beff=calcSinkB();
	
	static int lastremove=0;
	
	// calculate number of vortices in removal zone
	int sinkCount=0;
	for (std::list<CParticle>::iterator p = vorticesList.begin();
		p != vorticesList.end(); ++p) {
		if (p->get_x() > 2*bathLength+channelLength-5*a0) sinkCount++;
	}

	// This value needs to be half the flow rate, hence the /2.0
  // This ensures the sink can remove up to double the vortices it needs to
	// to give the correct density.
	// It should still allow very wide channels to maintain the correct sink density
  // without removing too many vortices and causing a sparsely occupied sink
  double lastremovetime=	a0/get_tAvSAvVelX()/dt/channelWidth*b0/2.0;

	if (Beff>sinkBfield && sinkCount!=0 && t-lastremove>=lastremovetime  ) { // remove a sinkVortex
		std::cout << "Lastremovetime: " << lastremovetime << std::endl;	
		bool removed=false;
		lastremove=t;
		std::list<CParticle>::iterator itSink = vorticesList.begin();
		while (false==removed) {
		//cerr << "Remove count: " << removecount << endl;
			if ( (itSink->get_x()>2*bathLength+channelLength-5*a0)  )		
			 {
				
				escapedTrajectoryOutput(itSink); 
				 
			  std::cout << "Removed by NormaliseSink at " << t << " pos (" <<  itSink->get_x() << ", " << itSink->get_y() << ") vel (" << itSink->get_velx() << ", " << itSink->get_vely() << ")" << std::endl;  
				itSink=vorticesList.erase(itSink);
				removed=true;
				//oss << " Sink Count: " << sinkCount-1;
			}
			itSink++;
		}
		
	
	}
	
	
}



void CSimulation::delaunayTriangulation(/*list<CParticle>::iterator& corner, */std::list<CParticle> vorticesList_/*, list<CParticle>& delVortexList, list<CParticle>& pinsList, list<CDelLine>& delLinesList, list<CDelTriangle>& delTrianglesList*/) {
	
	delVortexList.clear();
	delLinesList.clear();
	
	std::list<CLineIDs> lines;
	
	//std::cout << "Start Triangulation" << std::endl;
	//add edge of pins list to vortices list
	
	for(std::list<CParticle>::iterator p=pinsList.begin();
			p!=pinsList.end();p++){
		if (  p->get_x() > etchchannelx0 && p->get_x() < etchchannelx1
			  && p->get_y() > etchchannely0-a0 && p->get_y() < etchchannely1+a0 ){
				(*p).set_ghost();	
			vorticesList_.push_back(*p);
		}
	}
	
	// wrap vortices for correct triangulation in tube
	if (tube==geometry)
	{
		for (std::list<CParticle>::iterator p = vorticesList.begin();
			p!=vorticesList.end(); ++p )
		{
			if (p->get_y() <= 2*b0)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()+channelWidth+b0);
				newVortex.set_ghost();
				vorticesList_.push_back(newVortex);
			}
			else if (p->get_y() >= channelWidth-2*b0)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()-channelWidth-b0);
				newVortex.set_ghost();
				vorticesList_.push_back(newVortex);
			}
		
		}
		
		
	}
	else if (periodic==geometry)
	{
		
		wrapVorticesPeriodic(vorticesList_);
		
	}
	
	
	// node list is created by this point
	
	// pass this list to triangle_api
	
	//make an array of points
	
	//struct triangulateio in, mid, out, vorout;

  /* Define input points. */

  int numberofpoints = vorticesList_.size();
  
  
  point2d pointlist[100000];
  
  std::vector<CParticle> vorticesVector;
  std::copy( vorticesList_.begin(), vorticesList_.end(), std::back_inserter( vorticesVector ) );
  
  
  
  int count=0;
  for (std::vector<CParticle>::iterator p = vorticesVector.begin();
			p!=vorticesVector.end(); ++p )
	{
		p->set_coord_num(0);
		pointlist[count].x = p->get_x();
		pointlist[count].y = p->get_y();
		count++;
  }
	
	
	int *faces = NULL;
	
	int num_faces = delaunay2d((double*)pointlist,numberofpoints,&faces);
	
	int offset = 0;
	
	//std::cout << "lines: " << lines.size() << std::endl;
	
	std::vector<int> poly;
	for(int i = 0; i < num_faces; i++ )
		{
		poly.clear();
		
			
			int num_verts = faces[offset];
			
			offset++;
			for( int j = 0; j < num_verts; j++ )
			{
				int p0 = faces[offset + j];
				int p1 = faces[offset + (j+1) % num_verts];
				
				poly.push_back(p0);
				
				
			}
			
			offset += num_verts;
		
			
			
			for (int p=0;p<poly.size()-1;p++)
			{
				
				
				
				CLineIDs newline(poly[p],poly[p+1]);
			
				lines.push_back(newline);
				
			
			}
			
					
		
		}
		
	free(faces);
	
	
	
	
	// check delLinesList for dupilcates
	//std::cout << "lines: " << lines.size() << std::endl;
	lines.sort();
	//std::cout << "lines sort: " << lines.size() << std::endl;
	lines.unique();
	//std::cout << "lines unique: " << lines.size() << std::endl;
	
	for (std::list<CLineIDs>::iterator p = lines.begin();
		p!=lines.end(); ++p)
	{
		//std::cout << p->id1 <<  "   " << p->id2 << std::endl;
	
		
		CDelLine newDelLine;
		newDelLine.set_points(vorticesVector[p->id1].get_x(),vorticesVector[p->id1].get_y(),vorticesVector[p->id2].get_x(),vorticesVector[p->id2].get_y());
		delLinesList.push_back(newDelLine);	
		// work out coord num
		vorticesVector[p->id1].coordPlusOne();
		vorticesVector[p->id2].coordPlusOne();
	}
	
	
	
	std::copy( vorticesVector.begin(), vorticesVector.end(), std::back_inserter( delVortexList ) );
  
	// remove lines between baths and channel passing over the CE
	
	std::list<CDelLine>::iterator p = delLinesList.begin();
  
	if (channel==geometry) 
	{
		while (p != delLinesList.end())
		{
			bool removed=false;
		
			
			if ((p->get_x1() < bathLength && p->get_y1() < 0  &&  p->get_x2() > bathLength)
			|| (p->get_x2() < bathLength && p->get_y2() < 0  &&  p->get_x1() > bathLength))
			{
				p=delLinesList.erase(p);
				removed=true;	
			} 
			
			if ((p->get_x1() < bathLength && p->get_y1() > channelWidth+b0  &&  p->get_x2() > bathLength)
			|| (p->get_x2() < bathLength && p->get_y2() > channelWidth+b0  &&  p->get_x1() > bathLength)) 
			{
				p=delLinesList.erase(p);
				removed=true;	
			} 
			
			if ((p->get_x1() > bathLength+channelLength && p->get_y1() < 0  &&  p->get_x2() < bathLength+channelLength)
			|| (p->get_x2() > bathLength+channelLength && p->get_y2() < 0  &&  p->get_x1() < bathLength+channelLength)) 
			{
				p=delLinesList.erase(p);
				removed=true;	
			} 
			
			if ((p->get_x1() > bathLength+channelLength && p->get_y1() > channelWidth+b0  &&  p->get_x2() < bathLength+channelLength)
			|| (p->get_x2() > bathLength+channelLength && p->get_y2() > channelWidth+b0  &&  p->get_x1() < bathLength+channelLength)) 
			{
				p=delLinesList.erase(p);
				removed=true;	
			} 
			
		
			if (removed==false) { ++p; }
		}
	}
	else if (tube==geometry)
	{
		while (p != delLinesList.end())
		{
			bool removed=false;
		
			
			if (p->get_y1() <= removetopchannely || p->get_y2() <= removetopchannely ||
				p->get_y1() >=removebottomchannely || p->get_y2() >= removebottomchannely)
			{
				p=delLinesList.erase(p);
				removed=true;	
			} 
		
			if (removed==false) { ++p; }
		}
	}
	
	//std::cout << "Triangulation finished" << std::endl;
	
}

double CSimulation::dotProduct(CCoord a, CCoord b) {
	return a.get_x() * b.get_x() + a.get_y() * b.get_y();
	
}

double CSimulation::det(double a, double b, double c, double d, double e, double f, double g, double h, double i){
	/*
	  a  b  c 
	  d  e  f
	  g  h  i
	*/

	return a*( e*i - h*f) -b*(d*i-g*f) +c*(d*h -g*e);
}

double CSimulation::circum(std::list<CDelTriangle>::iterator p,std::list<CParticle>::iterator q) {
	double Ax, Bx, Cx, Dx, Ay, By, Cy, Dy;
	Ax=p->get_Ax();
	Ay=p->get_Ay();
	Bx=p->get_Bx();
	By=p->get_By();
	Cx=p->get_Cx();
	Cy=p->get_Cy();
	Dx=q->get_x();
	Dy=q->get_y();
	return det(	Ax-Dx,Ay-Dy,Ax*Ax-Dx*Dx+Ay*Ay-Dy*Dy,
				Bx-Dx,By-Dy,Bx*Bx-Dx*Dx+By*By-Dy*Dy,
				Cx-Dx,Cy-Dy,Cx*Cx-Dx*Dx+Cy*Cy-Dy*Dy);
	
}

bool CSimulation::pointInTriangle( CDelTriangle& p,  std::list<CParticle>::iterator& q) {
	
	CCoord Q;
	
	CCoord A;
	CCoord B;
	CCoord C;
	CCoord v0;
	CCoord v1;
	CCoord v2;
	
	double dot00, dot01, dot02, dot11, dot12, invDenom,u,v;
	bool inTriangle=false;
	
	A.set_coords(p.get_Ax(),p.get_Ay());
	B.set_coords(p.get_Bx(),p.get_By());
	C.set_coords(p.get_Cx(),p.get_Cy());
	Q.set_coords(q->get_x(),q->get_y());
	
	
	
	v0 = C - A;
	v1 = B - A;
	v2 = Q - A;
	//cout << "v0: ("  << C.get_x() << ", " << C.get_y() << ") - ("  << A.get_x() << ", " << A.get_y() << ") = (" << v0.get_x() << ", " << v0.get_y() << ")" << endl;
	//cout << "v1: ("  << B.get_x() << ", " << B.get_y() << ") - ("  << A.get_x() << ", " << A.get_y() << ") = (" << v1.get_x() << ", " << v1.get_y() << ")" << endl;
	//cout << "v2: ("  << Q.get_x() << ", " << Q.get_y() << ") - ("  << A.get_x() << ", " << A.get_y() << ") = (" << v2.get_x() << ", " << v2.get_y() << ")" << endl;
	
	// calculate dot products
	dot00 = dotProduct(v0, v0);
	dot01 = dotProduct(v0, v1);
	dot02 = dotProduct(v0, v2);
	dot11 = dotProduct(v1, v1);
	dot12 = dotProduct(v1, v2);

	// Compute barycentric coordinates
	invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
	u = (dot11 * dot02 - dot01 * dot12) * invDenom;
	v = (dot00 * dot12 - dot01 * dot02) * invDenom;

	// Check if point is in triangle
	
	if ((u >= 0) && (v >= 0) && (u + v < 1)) {inTriangle =true;}
	return inTriangle;
	 /*
	
	// Compute vectors        
	v0 = C - A
	v1 = B - A
	v2 = Q - A

	
	dot00 = dot(v0, v0)
	dot01 = dot(v0, v1)
	dot02 = dot(v0, v2)
	dot11 = dot(v1, v1)
	dot12 = dot(v1, v2)

	// Compute barycentric coordinates
invDenom = 1 / (dot00 * dot11 - dot01 * dot01)
u = (dot11 * dot02 - dot01 * dot12) * invDenom
v = (dot00 * dot12 - dot01 * dot02) * invDenom

// Check if point is in triangle
return (u >= 0) && (v >= 0) && (u + v < 1)
	*/
	
	
}

inline bool CSimulation::eqtest( double a, double b) {
	/*double EQtollerance=1e-5; //was 1e-5
	if (std::fabs(a/b -1) < EQtollerance){
		 return true; }
	else
	{ return false; }*/
	
	if (a==b) return true;
	return false;
	
}


void CSimulation::initialiseVortices()
{
	
	std::cout << "Initialising Vortices..." << std::endl;
	std::cout << "   " << "sourceDensity: " << sourceDensity << std::endl;
	std::cout << "   " << "sinkDensity: " << sinkDensity << std::endl;
  
	
	std::ostringstream oss;
	char renderChar[100];
	std::string renderStr;
	
	oss.str("");
	oss << "startdataMesh//" << sourceBfield << "-" << bathLength/a0<< "x" << bathWidth/b0 << "-"
		<<  channelLength/a0 << "x" << channelWidth/b0 << "-"<< sinkBfield << "-l" << lambda/a0 << ".txt";
	
	std::cout << "   " << oss.str() << std::endl;
			
	std::ifstream myfile (oss.str().c_str());
	
	
	if (myfile.is_open()) {
		std::cout << "   " << "Initial Vortex Positions From File" << std::endl;
		//file = true;
		double xval;
		double yval;
    
    while ( myfile.good() )
    {
		myfile >> xval;
		myfile >> yval;
		
		CParticle newVortex;
		newVortex.set_pos(xval,yval);
		vorticesList.push_back(newVortex);
			
			
    }
    myfile.close();

	}
	else {
	
		std::cout << "   " << "no start data" << std::endl;
		//file = false;
	
		for (int i = 0; i<(sourceDensity);i++) {
				
			double xval,yval;
			
			xval = bathLength*(rand() % 1000)/1000.0;
			yval = bathWidth*(rand() % 1000)/1000.0;
			//yval = yval-channelOffset;
			
			CParticle newVortex;
				
			newVortex.set_pos(xval,yval);
			
			vorticesList.push_back(newVortex);
		
		}
		for (int i = 0; i<(sinkDensity);i++) {
		
			CParticle newVortex;
			double xval= bathLength*(rand() % 1000)/1000.0+channelLength+bathLength;
			double yval = bathWidth*(rand() % 1000)/1000.0;
			//yval = yval-channelOffset;
			//cout << "sink vortex: " << xval << ", " << yval << endl;
			newVortex.set_pos(xval,yval);
			vorticesList.push_back(newVortex);
			
			
		}	
		//cout << "sink done" << endl;
		
		
		
		for (int i = 0; i<(channelDensity);i++) {
		
			double xval = channelLength*(rand() % 1000)/1000.0+bathLength;
			double yval = channelWidth*(rand() % 1000)/1000.0;
			//cout << "channel vortex: " << xval << ", " << yval << endl;
			CParticle newVortex;
			newVortex.set_pos(xval,yval);
			vorticesList.push_back(newVortex);
		
		}	
		
	}
   
	std::cout << "   " << "initialiseVortices() created " << vorticesList.size() << " vortices." << std::endl << std::endl;
}

void CSimulation::removeEscapedVortices() {
  std::list<CParticle>::iterator p = vorticesList.begin();
  

  
  
	while (p != vorticesList.end())
	{
		bool removed=false;
		
		if (p->get_x() <= removesourcex)
		{
			
			escapedTrajectoryOutput(p);
			
			std::cout << "Removed at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p=vorticesList.erase(p);
			//p--;
			removed=true;
			
		}
		else if (p->get_y() <= removesourcey0)
		{
			
			escapedTrajectoryOutput(p);
			
			std::cout << "Removed at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p=vorticesList.erase(p);
			//p--;
			removed=true;
		}
		else if (p->get_x() >= removesinkx)
		{
			
			escapedTrajectoryOutput(p);
			
			std::cout << "Removed at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p=vorticesList.erase(p);
			//p--;
			removed=true;
			
		} 
		else if (p->get_y() >= removesourcey1)
		{
			
			escapedTrajectoryOutput(p);
			
			std::cout << "Removed at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p=vorticesList.erase(p);
			//p--;
			removed=true;
		} 
		else if ( (p->get_x() >= removechannelx0 && p->get_x()<= removechannelx1) 
				&& ( p->get_y() <= removetopchannely  || p->get_y() >= removebottomchannely ) )
		{
			escapedTrajectoryOutput(p);
			
			std::cout << "Channel Removed at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p=vorticesList.erase(p);
			//p--;
			removed=true;
			
		} 
		
		
		
	
	
	
		if (removed==false) { ++p; }
	
	}
}


void CSimulation::calculateForces()
{
	M2=0;
	M2Full=0;
	kicks=0;
	int Nc=0;
	
	// create the full list of vortices
	std::list<CParticle> lastvorticesList=vorticesList;
	
	if (tube==geometry) wrapVortices(lastvorticesList);
	if (periodic==geometry) wrapVorticesPeriodic(lastvorticesList);
	
	// divide the vorticesList and lastvorticesList into cells
	
	std::vector<CCell> vorticesCellList;
	std::vector<CCell> lastvorticesCellList;
	
	
	
	// cell-linked lists	
	CCell cll[100][100]; // for vortices
	CCell cllp[100][100]; // for pins
	
	
	
	for(std::list<CParticle>::iterator q = lastvorticesList.begin();
			q != lastvorticesList.end(); q++)
	{
		
		cll[what_icell(*q)][what_jcell(*q)].add_particle(*q); 
		//if (what_icell(*q)==2 && what_jcell(*q)==2) std::cout << q->get_x() << ", " << q->get_y() << std::endl;	
	
	}
	
	for(std::list<CParticle>::iterator q = pinsList.begin();
			q != pinsList.end(); q++)
	{
		
		cllp[what_icell(*q)][what_jcell(*q)].add_particle(*q); 
		//if (what_icell(*q)==2 && what_jcell(*q)==2) std::cout << q->get_x() << ", " << q->get_y() << std::endl;	
	
	}
	
	
	/*std::ofstream cllfile;
	cllfile.open("cll.txt");
	
	for (int i=0;i<= 99; i++)
	{	
		for (int j=0;j<=99;j++)
			cllfile << cll[i][j].get_cellList().size() << "  " ;
		cllfile << std::endl;
	}
	cll[2][2].list_particles();
	
	std::cout << "(2,2) size: " << cll[2][2].get_cellList().size() << std::endl;
	
	for (std::list<CParticle>::iterator itr = cll[2][2].cellList.begin();
				itr!=cll[2][2].cellList.end(); ++itr)
		{
			std::cout << itr->get_x() << std::endl;
		}	
			
	cllfile.close();
	*/
	
	std::vector<CParticle> vorticesVector;
  std::copy( vorticesList.begin(), vorticesList.end(), std::back_inserter( vorticesVector ) );
  
#pragma omp parallel for 
	//for(std::vector<CParticle>::iterator q = vorticesVector.begin();
	//				q != vorticesVector.end(); q++)
	for (int it = 0; it<vorticesVector.size();it++)
	
	{
		CParticle *q =&vorticesVector[it];
		
		//std::cout << "it: " << it << std::endl; 
		
		// nearest cells list
		std::list<CParticle> ncvorticesList;
		std::list<CParticle> ncpinsList;
		
		
		// make nearest cell pins list for this vortex
		
		//ncvorticesList.clear();
		int icell=what_icell(*q);
		int jcell=what_jcell(*q);
		//std::cout << "(" << icell << ", " << jcell << ")" << std::endl;
		
		if (0!=icell && 0!=jcell)
			ncvorticesList.insert(ncvorticesList.begin(),cll[icell-1][jcell-1].cellList.begin(),cll[icell-1][jcell-1].cellList.end());
		
		if (0!=icell)
		{
			ncvorticesList.insert(ncvorticesList.end(),cll[icell-1][jcell-0].cellList.begin(),cll[icell-1][jcell-0].cellList.end());
			ncvorticesList.insert(ncvorticesList.end(),cll[icell-1][jcell+1].cellList.begin(),cll[icell-1][jcell+1].cellList.end());
		}
		
		if (0!=jcell)
			ncvorticesList.insert(ncvorticesList.end(),cll[icell-0][jcell-1].cellList.begin(),cll[icell-0][jcell-1].cellList.end());
				
		ncvorticesList.insert(ncvorticesList.end(),cll[icell-0][jcell+1].cellList.begin(),cll[icell-0][jcell+1].cellList.end());
		
		if (0!=jcell)
			ncvorticesList.insert(ncvorticesList.end(),cll[icell+1][jcell-1].cellList.begin(),cll[icell+1][jcell-1].cellList.end());
		
		ncvorticesList.insert(ncvorticesList.end(),cll[icell+1][jcell-0].cellList.begin(),cll[icell+1][jcell-0].cellList.end());
		ncvorticesList.insert(ncvorticesList.end(),cll[icell+1][jcell+1].cellList.begin(),cll[icell+1][jcell+1].cellList.end());
		
		ncvorticesList.insert(ncvorticesList.end(),cll[icell][jcell].cellList.begin(),cll[icell][jcell].cellList.end());
		
		// make nearest cell pins list for this vortex
		
		
		icell=what_icell(*q);
		jcell=what_jcell(*q);
		//std::cout << "(" << icell << ", " << jcell << ")" << std::endl;
		
		if (0!=icell && 0!=jcell)
			ncpinsList.insert(ncpinsList.begin(),cllp[icell-1][jcell-1].cellList.begin(),cllp[icell-1][jcell-1].cellList.end());
		
		if (0!=icell)
		{
			ncpinsList.insert(ncpinsList.end(),cllp[icell-1][jcell-0].cellList.begin(),cllp[icell-1][jcell-0].cellList.end());
			ncpinsList.insert(ncpinsList.end(),cllp[icell-1][jcell+1].cellList.begin(),cllp[icell-1][jcell+1].cellList.end());
		}
		
		if (0!=jcell)
			ncpinsList.insert(ncpinsList.end(),cllp[icell-0][jcell-1].cellList.begin(),cllp[icell-0][jcell-1].cellList.end());
				
		ncpinsList.insert(ncpinsList.end(),cllp[icell-0][jcell+1].cellList.begin(),cllp[icell-0][jcell+1].cellList.end());
		
		if (0!=jcell)
			ncpinsList.insert(ncpinsList.end(),cllp[icell+1][jcell-1].cellList.begin(),cllp[icell+1][jcell-1].cellList.end());
		
		ncpinsList.insert(ncpinsList.end(),cllp[icell+1][jcell-0].cellList.begin(),cllp[icell+1][jcell-0].cellList.end());
		ncpinsList.insert(ncpinsList.end(),cllp[icell+1][jcell+1].cellList.begin(),cllp[icell+1][jcell+1].cellList.end());
		
		ncpinsList.insert(ncpinsList.end(),cllp[icell][jcell].cellList.begin(),cllp[icell][jcell].cellList.end());
		
		
		
		
		
		double JyyK=0;  // kinetic term
		double JyyV=0;  // potential term
		
		double JxxK=0;  // kinetic term
		double JxxV=0;  // potential term
		
		double JxyK=0;  // kinetic term
		double JxyV=0;  // potential term
		
		double JyxK=0;  // kinetic term
		double JyxV=0;  // potential term
		
		
			
		double forcex=0;
		double forcey=0;
		
		// temp solution
		double v1[2]={0,0};
		double v2[2]={0,0}; 
		double vortexSum[2]={0,0};
		double pinningSum[2]={0,0};
		double disorderSum[2]={0,0};
		double directionVector[2]={0,0};
		double tempSum[2]={0,0};
		
		
		JyyK=0;// -1*q->get_vely()*q->get_vely();
		JxxK=0;// -1*q->get_velx()*q->get_velx();
		JxyK=0;// -1*q->get_velx()*q->get_vely();
		JyxK=0;// -1*q->get_velx()*q->get_vely();
		
		
		double lorentzForceSum[2]={0,0};
		
		if(q->get_x() >bathLength && q->get_x() <bathLength+channelLength)
		{
			lorentzForceSum[0]=lorentzForce;
						
		}
		
		
		// vortex sum
		for (std::list<CParticle>::iterator p = ncvorticesList.begin();
				p != ncvorticesList.end(); ++p) {
			
			if (q->get_id()==p->get_id())
				continue;
					
					v1[0]=q->get_x();
					v1[1]=q->get_y();
					v2[0]=p->get_x();
					v2[1]=p->get_y();
					
					double distcal= sqrt((double)(v1[0]- v2[0])*(v1[0]- v2[0])+ (v1[1]- v2[1])*(v1[1]- v2[1]));
				  
				  if (distcal!=distcal) { // error checking
						std::cout << "distcal error in routine: calculateForces.  Error: nan" << std::endl; 
						std::cout << "t: " << t << "(" << v1[0] << ", " << v1[1] << ") (" << v2[0] << ", " << v2[1] << ")" << std::endl;
						
						std::cerr << "distcal error in routine: calculateForces.  Error: nan" << std::endl; 
						std::cerr << "t: " << t << "(" << v1[0] << ", " << v1[1] << ") (" << v2[0] << ", " << v2[1] << ")" << std::endl;
						
						
						}
					if (boost::math::isinf(distcal))
					std::cout << "t: " << t << "dist inf" << "(" << distcal << ")" << std::endl;
			
						
				if (distcal > forceRange) //only include close vortices
					continue;
					
					directionVector[0]=v2[0]-v1[0];
					directionVector[1]=v2[1]-v1[1];
					double mod = sqrt((double)directionVector[0]*directionVector[0]+directionVector[1]*directionVector[1]);
					
					if (0==mod) {
						
						if (0==rand()%2) vortexSum[0]=vortexSum[0]-forceForm(0.5*a0);
						else vortexSum[0]=vortexSum[0]+forceForm(0.5*a0);
						
						if (0==rand()%2) vortexSum[1]=vortexSum[1]-forceForm(0.5*a0);
						else vortexSum[1]=vortexSum[1]+forceForm(0.5*a0);
						
						std::cout << "Two vortices at identical positions" << std::endl;
						std::cout << p->get_x() << ", " << p->get_y() << std::endl;
						std::cout << q->get_x() << ", " << q->get_y() << std::endl;
						
					}
					else if (distcal<0.5*a0)
					{
						//std::cout << "less than a0 separation" << std::endl;
						distcal=0.5*a0;
						mod=0.5*a0; 
						directionVector[0]=directionVector[0]/mod;
						directionVector[1]=directionVector[1]/mod;
						double f=forceForm(distcal);
						vortexSum[0]=vortexSum[0]+f*directionVector[0];
						vortexSum[1]=vortexSum[1]+f*directionVector[1];
						
						JyyV+=0.5*(p->get_y()-q->get_y())*f*directionVector[1];
						JxxV+=0.5*(p->get_x()-q->get_x())*f*directionVector[0];
						JxyV+=0.5*(p->get_y()-q->get_y())*f*directionVector[0];
						JxyV+=0.5*(p->get_x()-q->get_x())*f*directionVector[1];
					}
					else {
						directionVector[0]=directionVector[0]/mod;
						directionVector[1]=directionVector[1]/mod;
						double f=forceForm(distcal);
						vortexSum[0]=vortexSum[0]+f*directionVector[0];
						vortexSum[1]=vortexSum[1]+f*directionVector[1];
						
						JyyV+=0.5*(p->get_y()-q->get_y())*f*directionVector[1];
						JxxV+=0.5*(p->get_x()-q->get_x())*f*directionVector[0];
						JxyV+=0.5*(p->get_y()-q->get_y())*f*directionVector[0];
						JxyV+=0.5*(p->get_x()-q->get_x())*f*directionVector[1];
					
					
					}
					
					if (vortexSum[0]!=vortexSum[0] || vortexSum[1] != vortexSum[1])
					std::cout << "t: " << t << "partial sum vort nan" << "(" << vortexSum[0] << ", " << vortexSum[1] << ") mod: " << mod << std::endl;
					if (boost::math::isinf(vortexSum[0]) || boost::math::isinf(vortexSum[1]))
					std::cout << "t: " << t << "partial sum vort inf" << "(" << vortexSum[0] << ", " << vortexSum[1] << ") mod: " << mod << std::endl;
		
					
					
				
				
			}
				
			
			
			
		if (vortexSum[0]!=vortexSum[0] || vortexSum[1] != vortexSum[1])
		std::cout << "t: " << t << "vort nan" << "(" << vortexSum[0] << ", " << vortexSum[1] << ")" << std::endl;
		if (boost::math::isinf(vortexSum[0]) || boost::math::isinf(vortexSum[1]))
		std::cout << "t: " << t << "vort inf" << "(" << vortexSum[0] << ", " << vortexSum[1] << ")" << std::endl;
		
		
		
		// CE sum
		
		for (std::list<CParticle>::iterator p = ncpinsList.begin();
				p != ncpinsList.end(); ++p) {
		      v1[0]=q->get_x();
					v1[1]=q->get_y();
					v2[0]=p->get_x();
					v2[1]=p->get_y();
				
				double distcal= sqrt((double)(v1[0]- v2[0])*(v1[0]- v2[0])+ (v1[1]- v2[1])*(v1[1]- v2[1]));
				
				if (distcal!=distcal) { // error checking
						std::cout << "distcal error in routine: calculateForces.  Error: nan" << std::endl; 
						std::cout << "t: " << t << "(" << v1[0] << ", " << v1[1] << ") (" << v2[0] << ", " << v2[1] << ")" << std::endl;
						
						std::cerr << "distcal error in routine: calculateForces.  Error: nan" << std::endl; 
						std::cerr << "t: " << t << "(" << v1[0] << ", " << v1[1] << ") (" << v2[0] << ", " << v2[1] << ")" << std::endl;
						
						
				}
				
				if (distcal > forceRange) //only include close vortices
					continue;
						
						
					directionVector[0]=v2[0]-v1[0];
					directionVector[1]=v2[1]-v1[1];
					double mod = sqrt((double)directionVector[0]*directionVector[0]+directionVector[1]*directionVector[1]);
					
					if (0==mod) {
						
						if (0==rand()%2) pinningSum[0]=pinningSum[0]-forceForm(0.5*a0);
						else pinningSum[0]=pinningSum[0]+forceForm(0.5*a0);
						
						if (0==rand()%2) pinningSum[1]=pinningSum[1]-forceForm(0.5*a0);
						else pinningSum[1]=pinningSum[1]+forceForm(0.5*a0);
						
						std::cout << "Two vortices at identical positions" << std::endl;
						std::cout << p->get_x() << ", " << p->get_y() << std::endl;
						std::cout << q->get_x() << ", " << q->get_y() << std::endl;
						
					}
					else if (distcal<0.5*a0)
					{
						//std::cout << "less than a0 separation" << std::endl;
						distcal=0.5*a0;
						mod=0.5*a0; 
						directionVector[0]=directionVector[0]/mod;
						directionVector[1]=directionVector[1]/mod;
						double f=forceForm(distcal);
						pinningSum[0]=pinningSum[0]+f*directionVector[0];
						pinningSum[1]=pinningSum[1]+f*directionVector[1];
						
						JyyV+=0.5*(p->get_y()-q->get_y())*f*directionVector[1];
						JxxV+=0.5*(p->get_x()-q->get_x())*f*directionVector[0];
						JxyV+=0.5*(p->get_y()-q->get_y())*f*directionVector[0];
						JxyV+=0.5*(p->get_x()-q->get_x())*f*directionVector[1];
					}
					else {
						directionVector[0]=directionVector[0]/mod;
						directionVector[1]=directionVector[1]/mod;
						double f=forceForm(distcal);
						pinningSum[0]=pinningSum[0]+f*directionVector[0];
						pinningSum[1]=pinningSum[1]+f*directionVector[1];
						
						JyyV+=0.5*(p->get_y()-q->get_y())*f*directionVector[1];
						JxxV+=0.5*(p->get_x()-q->get_x())*f*directionVector[0];
						JxyV+=0.5*(p->get_y()-q->get_y())*f*directionVector[0];
						JxyV+=0.5*(p->get_x()-q->get_x())*f*directionVector[1];
					
					
					}
					
					if (pinningSum[0]!=pinningSum[0] || pinningSum[1] != pinningSum[1])
					std::cout << "t: " << t << "partial sum pin nan" << "(" << pinningSum[0] << ", " << pinningSum[1] << ") mod: " << mod << std::endl;
					if (boost::math::isinf(pinningSum[0]) || boost::math::isinf(pinningSum[1]))
					std::cout << "t: " << t << "partial sum pin inf" << "(" << pinningSum[0] << ", " << pinningSum[1] << ") mod: " << mod << std::endl;
		
					
				
			}
		if (pinningSum[0]!=pinningSum[0] || pinningSum[1] != pinningSum[1])
		std::cout << "t: " << t << "pin nan" << "(" << pinningSum[0] << ", " << pinningSum[1] << ")" << std::endl;
		if (boost::math::isinf(pinningSum[0]) || boost::math::isinf(pinningSum[1]))
		std::cout << "t: " << t << "pin inf" << "(" << pinningSum[0] << ", " << pinningSum[1] << ")" << std::endl;
		
		pinningSum[0]*=Ap;
		pinningSum[1]*=Ap;
		
		// Channel Disorder Sum
		
		for (std::vector<CPin>::iterator p = disorderVector.begin();
				p != disorderVector.end(); ++p) {
		      v1[0]=q->get_x();
					v1[1]=q->get_y();
					v2[0]=p->get_x();
					v2[1]=p->get_y();
				
				double distcal= sqrt((double)(v1[0]- v2[0])*(v1[0]- v2[0])+ (v1[1]- v2[1])*(v1[1]- v2[1]));
				
				if (distcal!=distcal) { // error checking
						std::cout << "distcal error in routine: calculateForces.  Error: nan" << std::endl; 
						std::cout << "t: " << t << "(" << v1[0] << ", " << v1[1] << ") (" << v2[0] << ", " << v2[1] << ")" << std::endl;
						
						std::cerr << "distcal error in routine: calculateForces.  Error: nan" << std::endl; 
						std::cerr << "t: " << t << "(" << v1[0] << ", " << v1[1] << ") (" << v2[0] << ", " << v2[1] << ")" << std::endl;
						
						
				}
				
				if (distcal > forceRange) //only include close disorder
					continue;
						
						
					directionVector[0]=v2[0]-v1[0];
					directionVector[1]=v2[1]-v1[1];
					double mod = std::sqrt((double)directionVector[0]*directionVector[0]+directionVector[1]*directionVector[1]);
					if (0!=mod) {
						directionVector[0]=directionVector[0]/mod;
						directionVector[1]=directionVector[1]/mod;
					}
					
					double f=disorderStrength*2*distcal*exp(-(distcal*distcal)/(double)(disorderRange*disorderRange))/disorderRange/disorderRange;
						
					disorderSum[0]=disorderSum[0]+f*directionVector[0];
					disorderSum[1]=disorderSum[1]+f*directionVector[1];
					
									
			}
		if (disorderSum[0]!=disorderSum[0] || disorderSum[1] != disorderSum[1])
		std::cout << "t: " << t << "disorder nan" << "(" << disorderSum[0] << ", " << disorderSum[1] << ")" << std::endl;
		if (boost::math::isinf(disorderSum[0]) || boost::math::isinf(disorderSum[1]))
		std::cout << "t: " << t << "disorder inf" << "(" << disorderSum[0] << ", " << disorderSum[1] << ")" << std::endl;
		
		
		// temperature
		
		if (q->get_x()>bathLength && q->get_x()<bathLength+channelLength)
		{
			Nc++;
			if ("Lindeman"==thermostat){
				
				tempSum[0]=LindemanTS();
			 	tempSum[1]=LindemanTS();
			}
			else if ("Anderson"==thermostat)
			{
				tempSum[0]=AndersonTS();
				if (0!=tempSum[0]) kicks++;
				
				tempSum[1]=AndersonTS();
			}
			
			
			if (tempSum[0]!=tempSum[0] || tempSum[1] != tempSum[1]) {
			  std::cout << "t: " << t << "temp nan" << "(" << tempSum[0] << ", " << tempSum[1] << ")" << std::endl;
				tempSum[0]=0;
			  tempSum[1]=0;
			}
			if (boost::math::isinf(tempSum[0]) || boost::math::isinf(tempSum[1]))
			std::cout << "t: " << t << "temperature inf" << "(" << tempSum[0] << ", " << tempSum[1] << ")" << std::endl;
		}
		
		//std::cout << vortexSum[0]+pinningSum[0]+disorderSum[0] << ", " << lorentzForceSum[0] << std::endl;
		
		forcex= vortexSum[0]+pinningSum[0]+disorderSum[0]+lorentzForceSum[0];
		forcey= vortexSum[1]+pinningSum[1]+disorderSum[1]+lorentzForceSum[1];
		
		 
		if (forcex!=forcex || forcey != forcey || tempSum[0] != tempSum[0]
		 || tempSum[1]!=tempSum[1])
		std::cout << "t: " << t << "force nan" << "(" << forcex << ", " << forcey << ")" << std::endl;
		if (boost::math::isinf(forcex) || boost::math::isinf(forcey))
		std::cout << "t: " << t << "force inf" << "(" << forcex << ", " << forcey << ")" << std::endl;
		
		if(tempSum[1]/dt>4.0*b0/dt)
				maxvelfile << "temp  " << q->get_x() << "  " << q->get_y() << std::endl;
		
		if(vortexSum[1]/eta>4.0*b0/dt)
				maxvelfile << "vvforce  " <<q->get_x() << "  " << q->get_y() << std::endl;

		if(pinningSum[1]/eta>4.0*b0/dt)
				maxvelfile << "vpforce  " <<q->get_x() << "  " << q->get_y() << std::endl;

			
		
		double velx=forcex/eta+tempSum[0]/dt;
		double vely=forcey/eta+tempSum[1]/dt;
		q->set_force(forcex,forcey);
		if (q->get_x() >bathLength+channelLength)
		{ // rescaled viscosity for sink vortices
			velx=velx*2;
			vely=vely*2;
		}
		else if (q->get_x() <bathLength)
		{ // rescaled viscosity for sink vortices
			velx=velx*0.5;
			vely=vely*0.5;
		}
		
		
		
		if (velx!=velx) std::cout << "t: " << t << " velx nan" << std::endl;
		if (vely!=vely) std::cout << "t: " << t << " vely nan" << std::endl;
		if (boost::math::isinf(velx) || boost::math::isinf(vely)) std::cout << "t: " << t << " vel nan " << velx << ", " << vely << std::endl; 
		
		q->set_vel(velx,vely);
		//std::cout << "dt=" << dt << std::endl;
		//std::cout << "v passed to object (" << velx << ", " << vely << ")" << std::endl; 
		//std::cout << "MAX allowed dr/dt: " << 0.5*b0/dt<< std::endl;
		//std::cout << "v returned from object (" << q->get_velx() << ", " << q->get_vely() << ")" << std::endl; 
		
		// Velocities are allowed to be a maximum 0.5*b0 /dt to avoid escaping vortices
		if (periodic==geometry)
		{
			double maxvel=4*b0/dt;
			if(q->get_velx()>maxvel) {
				//std::cout << "  vx velocity rectified " << q->get_velx(); 
				q->set_velx(maxvel);
				//std::cout << " changed to " << std::setw(15) << q->get_velx() << std::endl;
			}
			
			if(q->get_velx()<-maxvel) {
				//std::cout << "  vx velocity rectified " << q->get_velx(); 
				q->set_velx(-maxvel);
				//std::cout << " changed to " << std::setw(15) << q->get_velx() << std::endl;
			}
			
			
			if(q->get_vely()>maxvel) {
				//std::cout << "  vy velocity rectified " << q->get_vely(); 
			  q->set_vely(maxvel);
			 // std::cout << " changed to "<< std::setw(15) << q->get_vely() << std::endl;
			}
			
			if(q->get_vely()<-maxvel) {
				//std::cout << "  vy velocity rectified " << q->get_vely(); 
			  q->set_vely(-maxvel);
			 // std::cout << " changed to "<< std::setw(15) << q->get_vely() << std::endl;
			}
			q->set_pos(q->get_x()+q->get_velx()*dt,q->get_y()+q->get_vely()*dt);
		
			//if (fabs(q->get_velx()*dt)>0.02*a0) std::cout << "t: " << t << " drx=" << 100*q->get_velx()*dt/a0 << "% of a0" << std::endl;  
			
			//if (fabs(q->get_vely()*dt)>0.02*a0) std::cout << "t: " << t << " dry=" << 100*q->get_vely()*dt/a0 << "% of a0" << std::endl;  
				
			if (q->get_velx()*dt>maxvel*dt || q->get_velx()*dt<-maxvel*dt ) {
				std::cout << "vibration bigger than 0.5b0 in a single timestep!" << std::endl;
			}
		  
			if (q->get_vely()*dt>maxvel*dt || q->get_vely()*dt<-maxvel*dt ) {
				std::cout << "vibration bigger than 0.5b0 in a single timestep!" << std::endl;
			}
			
			
			
		}
		else
		{
			double maxvel;//=4.0*b0/dt;
			if(q->get_x()<bathLength || q->get_x()>channelLength+bathLength) maxvel=0.5*b0/dt;
			else maxvel=4.0*b0/dt;
			 
			if(q->get_velx()>maxvel) {
				//std::cout << "  vx velocity rectified " << q->get_velx(); 
				//maxvelfile << q->get_x() << "  " << q->get_y() << std::endl;
				
				q->set_velx(maxvel);
				//std::cout << " changed to " << std::setw(15) << q->get_velx() << std::endl;
			}
			
			if(q->get_velx()<-maxvel) {
				//std::cout << "  vx velocity rectified " << q->get_velx(); 
				//maxvelfile << q->get_x() << "  " << q->get_y() << std::endl;
				
				q->set_velx(-maxvel);
				//std::cout << " changed to " << std::setw(15) << q->get_velx() << std::endl;
			}
			
			
			if(q->get_vely()>maxvel) {
				//std::cout << "  vy velocity rectified " << q->get_vely(); 
			  //maxvelfile << q->get_x() << "  " << q->get_y() << std::endl;
				
			  q->set_vely(maxvel);
			 // std::cout << " changed to "<< std::setw(15) << q->get_vely() << std::endl;
			}
			
			if(q->get_vely()<-maxvel) {
				//std::cout << "  vy velocity rectified " << q->get_vely(); 
			  //maxvelfile << q->get_x() << "  " << q->get_y() << std::endl;
				
				q->set_vely(-maxvel);
			 // std::cout << " changed to "<< std::setw(15) << q->get_vely() << std::endl;
			}
			
			// check if vortex escapes channel. If so rebound.
			if (q->get_x()>bathLength && q->get_x()<bathLength+channelLength)
			{
				
				if (q->get_y()+q->get_vely()*dt>channelWidth+b0/2.0)
				{
					double reflect_distance=q->get_y()+q->get_vely()*dt-channelWidth-b0/2.0;
					double reflect_position=channelWidth+b0/2.0-reflect_distance;
					double lasty = q->get_y();
					q->set_pos(q->get_x()+q->get_velx()*dt,reflect_position);
					q->set_vel(q->get_velx(),(q->get_y()-lasty)/dt);
					//std::cout << "Reflected top: " << q->get_vely() << std::endl;
				}
				else if (q->get_y()+q->get_vely()*dt<-b0/2.0)
				{
					double reflect_distance=-b0/2.0-(q->get_y()+q->get_vely()*dt);
					double reflect_position=-b0/2.0+reflect_distance;
					double lasty = q->get_y();
					q->set_pos(q->get_x()+q->get_velx()*dt,reflect_position);
					q->set_vel(q->get_velx(),(q->get_y()-lasty)/dt);
					//std::cout << "Reflected bottom: " << q->get_vely() << std::endl;
				}
				else
				{
					q->set_pos(q->get_x()+q->get_velx()*dt,q->get_y()+q->get_vely()*dt);
				}
			}
			else
			{
				q->set_pos(q->get_x()+q->get_velx()*dt,q->get_y()+q->get_vely()*dt);
			
			}
				
			//if (fabs(q->get_velx()*dt)>0.02*a0) std::cout << "t: " << t << " drx=" << 100*q->get_velx()*dt/a0 << "% of a0" << std::endl;  
			
			//if (fabs(q->get_vely()*dt)>0.02*a0) std::cout << "t: " << t << " dry=" << 100*q->get_vely()*dt/a0 << "% of a0" << std::endl;  
				
			if (q->get_velx()*dt>maxvel*dt || q->get_velx()*dt<-maxvel*dt ) {
				std::cout << "vibration bigger than 0.5b0 in a single timestep!" << std::endl;
			}
		  
			if (q->get_vely()*dt>maxvel*dt || q->get_vely()*dt<-maxvel*dt ) {
				std::cout << "vibration bigger than 0.5b0 in a single timestep!" << std::endl;
			}
		
		
		}	
		//std::cout << "pos: " << q->get_x() << ", " << q->get_y() << std::endl;
		
	  
		// calculate dx2
		M2+=tempSum[0]*tempSum[0];
		M2Full+=q->get_velx()*dt*q->get_velx()*dt;
		M2file << t << " " << tempSum[0] << std::endl;
	  // Set partilces local stress
	  
	  q->set_Jyy(JyyK+JyyV);
	  q->set_Jxx(JxxK+JxxV);
	  q->set_Jxy(JxyK+JxyV);
	  q->set_Jyx(JyxK+JyxV);

  
	}
	
	
	vorticesList.clear();
	
	std::copy( vorticesVector.begin(), vorticesVector.end(), std::back_inserter( vorticesList ) );
  
		
    if ("Anderson"==thermostat/* && 0!=kicks*/)
    {
			M2=M2/dt/(double)Nc;
			M2Full=M2Full/dt/(double)Nc;
		}
	else if ("Lindeman"==thermostat) M2=M2/(double)Nc;
	else M2=0;
	
	M2Sum=M2Sum+M2;
	M2FullSum=M2FullSum+M2Full;
}

//void CSimulation::calculateForcesJM()
//{
	/* Sub routine to calculate forces (and virial stress)
	 * using Jensons method 
	 * 
	 * 
	 * 
	 */
//}	
	
	
	
	



/*void CParticle::wrapVortices(std::list<CParticle>& vorticesList_) {
	std::list<CParticle> wrappedVorticesList;
	wrappedVorticesList=vorticesList_;
	for (std::list<CParticle>::iterator p = vorticesList_.begin();
			p!=vorticesList_.end(); ++p ) {
		// wrap vortices on tube
		if (p->get_x() >=0) {
			if (p->get_y() <= forceRange) {
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()+channelWidth+b0);
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			else if (p->get_y() >= channelWidth-forceRange) {
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()-channelWidth-b0);
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
		}
		else if (p->get_x() < 0) {  // wrap vortices on cone
			if (p->get_y() <= -fabs(p->get_x())*tan(funnelAngle)+forceRange) {
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()+channelHeight+b0+2.0*fabs(p->get_x())*tan(funnelAngle) );
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			else if (p->get_y() >= channelHeight+fabs(p->get_x())*tan(funnelAngle)-forceRange) {
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()-channelHeight-b0-2.0*fabs(p->get_x())*tan(funnelAngle));
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			
		}
		
		
		
	}
	vorticesList_=wrappedVorticesList;
	
}*/


double CSimulation::forceForm(double dist_) const
{
	double force=0;
	
	if (dist_==0)
	{
		std::cout << "zero" << std::endl;
		force=-0.0000000001*fabs(gaussianRand());
	}
	else
	{
		force = f0*boost::math::cyl_bessel_k(1,  dist_/lambda);
	}
	
	return force;
	
}


double CSimulation::gaussianRand() const
{
	double result;
	do
	{
		double u1 = (float)rand()/(float)RAND_MAX;
		double u2 = (float)rand()/(float)RAND_MAX;
		result = std::sqrt((double)-2*std::log(u1))*std::cos(2*pi*u2);
	}
	while ( boost::math::isnan((double)result)==true || boost::math::isinf(result)==true  || result >1 || result <-1);
	
	if (result != result)
	{
		std::cout << "ERR: gaussian rand result: " << "(" << result << ")" << std::endl;
	}
	
	if (boost::math::isinf(result)) std::cout << "inf: gaussian rand result: " << "(" << result << ")" << std::endl;
		 
	return result;
}


void CSimulation::initialiseVorticesTube()
{
	
	std::cout << "Initialising Vortices (Tube)..." << std::endl;
	std::cout << "   " << "sourceDensity: " << sourceDensity << std::endl;
	std::cout << "   " << "sinkDensity: " << sinkDensity << std::endl;
	
	std::ostringstream oss;
	char renderChar[100];
	std::string renderStr;
	
	oss.str("");
	oss << "startdataMesh//TE-" << sourceBfield << "-" << bathLength/a0<< "x" << bathWidth/b0 << "-" <<  channelLength/a0 << "x" << channelWidth/b0 << "-"<< sinkBfield << "-l" << lambda/a0 << ".txt";
	
	std::cout << "   " << oss.str() << std::endl;
	
	std::ifstream myfile (oss.str().c_str());
	
	
	if (myfile.is_open()) 
	{
		std::cout << "   " << "Initial Vortex Positions From File" << std::endl;
		
		double xval;
		double yval;
	
		while ( myfile.good() )
		{
			myfile >> xval;
			myfile >> yval;
		
			CParticle newVortex;
			newVortex.set_pos(xval,yval);
			vorticesList.push_back(newVortex);
	
		}
		myfile.close();
	
	}
	else
	{
		std::cout << "   " << "no start data" << std::endl;
		
		for (int i = 0; i<(sourceDensity);i++)
		{
			double xval,yval;
	
			xval = bathLength*(rand() % 1000)/1000.0;
			yval = bathWidth*(rand() % 1000)/1000.0;
			
	
	
			CParticle newVortex;
	
			newVortex.set_pos(xval,yval);
	
			vorticesList.push_back(newVortex);
	
		}
		for (int i = 0; i<(sinkDensity);i++)
		{
			CParticle newVortex;
			double xval= bathLength*(rand() % 1000)/1000.0+bathLength+channelLength;
			double yval = bathWidth*(rand() % 1000)/1000.0;
			
		
			newVortex.set_pos(xval,yval);
			vorticesList.push_back(newVortex);
		
		
		}	
	
	
	
		for (int i = 0; i<(channelDensity);i++)
		{
			double xval = channelLength*(rand() % 1000)/1000.0+bathLength;
			double yval = channelWidth*(rand() % 1000)/1000.0;
			
			
			CParticle newVortex;
			newVortex.set_pos(xval,yval);
			vorticesList.push_back(newVortex);
			
		}	
	
	
	
	
	}
	
	std::cout << "   " << "initialiseVorticesTube() created " << vorticesList.size() << " vortices." << std::endl << std::endl;
}


void CSimulation::initialisePinsTube()
{
	std::cout << "Initialising pins(Tube)..." << std::endl;
	
	double locala0=a0/1.5;
	double localb0=b0/1.5;
	double xPos;
	
	systemWidth=20*localb0+channelWidth+3*localb0/2.0;
	systemLength=6*locala0+2*bathLength+channelLength+locala0/2.0;
	
	firstPin.set_pos(-3*a0,-10*localb0-channelOffset);
	
	double yPos=firstPin.get_y();
	
	//std::cout << "Bottom Limit: " << yPos << std::endl; 
	//std::cout << "Top Limit: " << bathWidth+6*localb0-channelOffset << std::endl; 
	
	while (yPos<channelWidth+10*localb0-channelOffset-0.1*b0)
	{
		xPos=firstPin.get_x();

	    while (xPos<2*bathLength+channelLength+3*locala0)
	    {
			CParticle newPin;
			newPin.set_pos(xPos,yPos+localb0/2.0);
			pinsList.push_back(newPin);
					
			newPin.set_pos(xPos+locala0/2.0,yPos+3*localb0/2.0);
			pinsList.push_back(newPin);
			
			xPos=xPos+locala0;
			
		}
		
		yPos=yPos+2*localb0;
	}
		
	//etch source, sink and channel
	bool removed;
	
	std::list<CParticle>::iterator p= pinsList.begin();
	
	while (p!=pinsList.end())
	{
		
		removed=false;
		
		if (  p->get_x() > etchsourcex0 && p->get_x() < etchsinkx1
		  )
		{
			p=pinsList.erase(p);
			removed=true;
		}
		
		if (removed==false) { ++p; }
	
			
	}
	
	std::cout << "   initialisePinsTube() created " << pinsList.size() << " 'CE' vortices." << std::endl <<std::endl;

}

void CSimulation::removeEscapedVorticesTube() {
  
  std::list<CParticle>::iterator p = vorticesList.begin();
  

  
  
	while (p != vorticesList.end()) {
		bool removed=false;
		/*if (p->get_x() <= removefunnelx) {
			cout << "Removed at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << endl;  
			p=vorticesList.erase(p);
			//p--;
			removed=true;
			
		}
		else if (p->get_y() <= -funnelWidth*tan(funnelAngle)-2*b0 || p->get_y() >= funnelWidth*tan(funnelAngle)+channelHeight+2*b0) {
			cout << "Removed at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << endl;  
			p=vorticesList.erase(p);
			//p--;
			removed=true;
		
		}
		else*/
		if (p->get_x() <= removesourcex)
		{
			
			escapedTrajectoryOutput(p);
			
			std::cout << "Removed at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			
			p=vorticesList.erase(p);
			//p--;
			removed=true;
			
		}
		else if (p->get_x() >= removesinkx)
		{
			
			escapedTrajectoryOutput(p);
			
			std::cout << "Removed at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  

			p=vorticesList.erase(p);
			//p--;
			removed=true;
			
		} 
		
		/* else if ((p->get_y() <= removesourcey0) and  (p->get_x() < removechannelx0 ) )  {
			cout << "wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << endl;  
			//p=vorticesList.erase(p);
			p->set_pos(p->get_x(),p->get_y()+channelHeight+b0);
			//p--;
			//removed=true;
		
		} else if ((p->get_y() > removesourcey1) and  (p->get_x() < removechannelx0) )  {
			cout << "wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << endl;  
			//p=vorticesList.erase(p);
			p->set_pos(p->get_x(),p->get_y()-channelHeight-b0);
			//p--;
			//removed=true;
		
		}*/
		 else if ((p->get_y() <= removetopchannely) &&  (p->get_x() > removesourcex) )  {
			std::cout << "wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p->set_pos(p->get_x(),p->get_y()+channelWidth+b0);
			//p=vorticesList.erase(p);
			//p--;
			//removed=true;
		}  else if ((p->get_y() >= removebottomchannely) &&  (p->get_x() > removesourcex) )  {
			std::cout << "wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p->set_pos(p->get_x(),p->get_y()-channelWidth-b0);
			//p=vorticesList.erase(p);
			//p--;
			//removed=true;
		}
		
		
		
		/*else if ((p->get_y() <= -fabs(p->get_x())*tan(funnelAngle) ) &&  (p->get_x() < removesourcex) )  {
			cout << "funnel wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p->set_pos(p->get_x(),p->get_y()+channelHeight+b0+2.0*p->get_x()*tan(funnelAngle));
			//p=vorticesList.erase(p);
			//p--;
			//removed=true;
		}  else if ((p->get_y() >= channelHeight+b0+fabs(p->get_x())*tan(funnelAngle)) &&  (p->get_x() < removesourcex) )  {
			cout << "funnel wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << endl;  
			p->set_pos(p->get_x(),p->get_y()-channelHeight-b0-2.0*p->get_x()*tan(funnelAngle));
			//p=vorticesList.erase(p);
			//p--;
			//removed=true;
		}*/
		
		
		
		
		
		
	
	
	
		if (removed==false) { ++p; }
	
	}
}


void CSimulation::wrapVortices(std::list<CParticle>& vorticesList_)
{
	std::list<CParticle> wrappedVorticesList;
	wrappedVorticesList=vorticesList_;
	
	for (std::list<CParticle>::iterator p = vorticesList_.begin();
		p!=vorticesList_.end(); ++p )
	{
		// wrap vortices on tube
		//if (p->get_x() >=0) {
			if (p->get_y() <= forceRange)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()+channelWidth+b0);
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			else if (p->get_y() >= channelWidth-forceRange)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()-channelWidth-b0);
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
		//}
		
		/*else if (p->get_x() < 0) {  // wrap vortices on cone
			if (p->get_y() <= -fabs(p->get_x())*tan(funnelAngle)+forceRange) {
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()+channelHeight+b0+2.0*fabs(p->get_x())*tan(funnelAngle) );
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			else if (p->get_y() >= channelHeight+fabs(p->get_x())*tan(funnelAngle)-forceRange) {
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()-channelHeight-b0-2.0*fabs(p->get_x())*tan(funnelAngle));
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			
		}*/
	}
	
	vorticesList_=wrappedVorticesList;
	
}



void CSimulation::normaliseSourceTube()
{
	static int lastadded=0;
	normaliseSourceStr = "";
	double aaverage=0;
	int numa=0;
	for (std::list<CDelLine>::iterator p = delLinesList.begin();
				p!=delLinesList.end(); ++p) {
		double midy = (p->get_y1() + p->get_y2())/2.0;
		double midx = (p->get_x1() + p->get_x2())/2.0;
						
		if ( midx> bathLength-binsize/2.0 && midx < bathLength+binsize/2.0 &&
				(midy>0 && midy<channelWidth))
		{
			double linelength=sqrt((double) (p->get_x1()-p->get_x2())*(p->get_x1()-p->get_x2())
																		+ (p->get_y1()-p->get_y2())*(p->get_y1()-p->get_y2()));
											
			aaverage=aaverage+linelength;
			numa++;	
		}			
	}
	aaverage=aaverage/(double)numa;
	
	double Beff=2*Phi/(sqrt((double)3)*aaverage*aaverage);		
	std::ostringstream oss;
	oss.str("");
	
	oss << "Bl(x="<<bathLength/a0<<"a0)=" << Beff << "T";
	
	
	
	
	// calculate zone densities
	int sourceCount=0;
	int sinkCount=0;
	
	// count densities
	for (std::list<CParticle>::iterator p = vorticesList.begin();
		p != vorticesList.end(); ++p) {
		if (p->get_x() < bathLength && (p->get_y()<0 || p->get_y()>channelWidth))
			      sourceCount++;
		if (p->get_x() > bathLength+channelLength && 
			     (p->get_y()<0 || p->get_y()>channelWidth)) sinkCount++;
	}
	
	if (Beff<sourceBfield && t-lastadded>=10) { // add a source vortex - at most every 10 steps
		lastadded=t;
	newVortexfile << std::setw(10) << t;
		
		
			CParticle newVortex;
			
			double xval = (bathLength-a0)*(rand() % 1000)/1000.0;
			double yval = bathWidth*(rand() % 1000)/1000.0;
			xval=xval+a0/2.0;
						
			newVortex.set_pos( xval,yval);
			
			vorticesList.push_back(newVortex);
			
			//output newVortex added data
		
			
		
		newVortexfile << std::setw(10) << 1 << std::endl;
		
	}
	
	
	
	normaliseSourceStr = oss.str();	
}
			
void CSimulation::read_PinsList()
{
	
	std::ostringstream oss;
	char renderChar[100];
	std::string renderStr;
	
	oss.str("");
	oss << /*ini.readDataLocation <<*/ jobnum << "//pinsdata.txt"; 
	
	renderStr = oss.str();
	std::cout << renderStr << std::endl;
	strcpy(renderChar,renderStr.c_str());
			
	std::ifstream myfile (renderChar);
	
	std::cout << "Loading pins data from file" << std::endl;
	
	if (myfile.is_open()) {
		
		double xval;
		double yval;
    
    while ( myfile.good() )
    {
		myfile >> xval;
		myfile >> yval;
		
		CParticle newVortex;
		newVortex.set_pos(xval,yval);
		pinsList.push_back(newVortex);
			
			
    }
    myfile.close();

	}
	else
	{
	
		std::cout << "No pins data" << std::endl;
		std::cerr << "Read run failed to initialise... No pins data found." << std::endl;
		t=simulation_time;
		return;
	}
	std::cout << "read_PinsList() created " << pinsList.size() << " CE vortices." << std::endl;
	
	
}

/*void CSimulation::read_JobHeader()
{
	
	std::ostringstream oss;
	char renderChar[100];
	std::string renderStr;
	
	oss.str("");
	oss << "job" << jobnum << "//jobheader.txt"; 
	
	renderStr = oss.str();
	std::cout << renderStr << std::endl;
	strcpy(renderChar,renderStr.c_str());
			
	std::ifstream readJobHeader (renderChar);
	
	std::cout << "Loading jobheader from file" << std::endl;
	
	
	if (readJobHeader.is_open()) {
		
		readJobHeader >> seedtime;
		readJobHeader >> sourceBfield;
		readJobHeader >> sinkBfield;
		readJobHeader >> bathLength;
		readJobHeader >> bathWidth;
		readJobHeader >> channelLength;
		readJobHeader >> channelWidth;
		
		readJobHeader >> simulation_time;
		readJobHeader >> tau;	
		double pinx;
		double piny;
		readJobHeader >> pinx;
		readJobHeader >> piny;
		firstPin.set_pos(pinx,piny);
		readJobHeader >> systemLength; 
		readJobHeader >> systemWidth;
		
		temp=tau;
		
		a0=1e-7;
	
		// analysis variables
		binsize=5*a0; 
	
		// physics variables and constants
		pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679;
		Phi=2.067e-15; // 2.067x10^-15 Wb 
		forceRange=3.0*a0;
		eta=1.0;  // not sure
		kB=1.0;
		mu0=(4e-7)*pi; // 4 pi x 10 ^-7 Vs/Am
		lambda=0.2*a0;//.2*a0;  // || 02.e-7
	
		// simulation variables
		dt=1e-5;
		drawInterval=5;
		triangulationInterval=5;
		
		
		
		
	}
	else
	{
		std::cerr << "Read run failed to initialise... Failed to load jobheader." << std::endl;
		t=simulation_time;
		return;
	}
	
	
	readJobHeader.close();

}
*/

void CSimulation::iniread_JobHeader()
{
	
	std::cout << "Loading job header..."  << std::endl;
	
	std::ostringstream oss;
	std::string renderStr;
	
	oss.str("");

#if defined(__WINDOWS__)
 oss << jobnum << "/jobheader.ini";
#else
  oss << jobnum << "//jobheader.ini";
#endif
	 
	
	std::cout << "   from " << oss.str() << std::endl;
	
	boost::property_tree::ptree pt;
	boost::property_tree::ini_parser::read_ini(oss.str(), pt);
	
	
	
	
	// Batch Options
	geometry= pt.get<double>("BatchOptions.geometry");

	sourceBfield= pt.get<double>("BatchOptions.sourceBfield");
	sinkBfield= pt.get<double>("BatchOptions.sinkBfield");
	bathLength= pt.get<double>("BatchOptions.bathLength");
	bathWidth= pt.get<double>("BatchOptions.bathWidth");
	channelLength= pt.get<double>("BatchOptions.channelLength");
	channelWidth= pt.get<double>("BatchOptions.channelWidth");
	simulation_time= pt.get<double>("BatchOptions.simulationTime");
	temp= pt.get<double>("BatchOptions.temp");
	
	
	
		
	//Config Variables	
	
	channelOffset = pt.get<double>("ConfigVariables.channelOffset");
	etchsourcex0 = pt.get<double>("ConfigVariables.etchsourcex0");
	etchsourcey0 = pt.get<double>("ConfigVariables.etchsourcey0");
	etchsourcex1 = pt.get<double>("ConfigVariables.etchsourcex1");
	etchsourcey1 = pt.get<double>("ConfigVariables.etchsourcey1");
	etchsinkx0 = pt.get<double>("ConfigVariables.etchsinkx0");
	etchsinky0 = pt.get<double>("ConfigVariables.etchsinky0");
	etchsinkx1 = pt.get<double>("ConfigVariables.etchsinkx1");
	etchsinky1 = pt.get<double>("ConfigVariables.etchsinky1");
	etchchannelx0 = pt.get<double>("ConfigVariables.etchchannelx0");
	etchchannely0 = pt.get<double>("ConfigVariables.etchchannely0");
	etchchannelx1 = pt.get<double>("ConfigVariables.etchchannelx1");
	etchchannely1 = pt.get<double>("ConfigVariables.etchchannely1");
	removesourcex = pt.get<double>("ConfigVariables.removesourcex");
	removesinkx = pt.get<double>("ConfigVariables.removesinkx");
	removesourcey0 = pt.get<double>("ConfigVariables.removesourcey0");
	removesourcey1 = pt.get<double>("ConfigVariables.removesourcey1");
	removechannelx0 = pt.get<double>("ConfigVariables.removechannelx0");
	removechannelx1 = pt.get<double>("ConfigVariables.removechannelx1");
	removetopchannely = pt.get<double>("ConfigVariables.removetopchannely");
	removebottomchannely = pt.get<double>("ConfigVariables.removebottomchannely");
	urectx0 = pt.get<double>("ConfigVariables.urectx0");
	urecty0 = pt.get<double>("ConfigVariables.urecty0");
	urectx1 = pt.get<double>("ConfigVariables.urectx1");
	urecty1 = pt.get<double>("ConfigVariables.urecty1");
	bulkx0 = pt.get<double>("ConfigVariables.bulkx0");
	bulky0 = pt.get<double>("ConfigVariables.bulky0");
	bulkx1 = pt.get<double>("ConfigVariables.bulkx1");
	bulky1 = pt.get<double>("ConfigVariables.bulky1");
	dislocationx0 = pt.get<double>("ConfigVariables.dislocationx0");
	dislocationy0 = pt.get<double>("ConfigVariables.dislocationy0");
	dislocationx1 = pt.get<double>("ConfigVariables.dislocationx1");
	dislocationy1 = pt.get<double>("ConfigVariables.dislocationy1");
	numBins = pt.get<double>("ConfigVariables.numBins");
	f0= pt.get<double>("ConfigVariables.f0");
	sourceDensity= pt.get<double>("ConfigVariables.sourceDensity");
	sinkDensity = pt.get<double>("ConfigVariables.sinkDensity");
	channelDensity= pt.get<double>("ConfigVariables.channelDensity");
	
	// Drawing Variables
	
	
	firstPin.set_pos(pt.get<double>("DrawingVariables.firstPinx"),pt.get<double>("DrawingVariables.firstPiny"));
	systemLength=pt.get<double>("DrawingVariables.systemLength");
	systemWidth=pt.get<double>("DrawingVariables.systemWidth");
	
	//General Parameters
	
	
	// geometry variables
	a0= pt.get<double>("GeneralParameters.a0");
	b0=(std::sqrt((double)3)/2.0)*a0;
	
	// analysis variables
	binsize=pt.get<double>("GeneralParameters.binSize");
	
	// physics variables and constants
	pi=pt.get<double>("GeneralParameters.pi");
	Phi=pt.get<double>("GeneralParameters.Phi");
	forceRange=pt.get<double>("GeneralParameters.forceRange");
	eta=pt.get<double>("GeneralParameters.eta");
	kB=pt.get<double>("GeneralParameters.kB");
	mu0=pt.get<double>("GeneralParameters.mu0");
	lambda=pt.get<double>("GeneralParameters.lambda");
	Ap=pt.get<double>("GeneralParameters.Ap");
	
	// simulation variables
	cellSize=pt.get<double>("GeneralParameters.cellSize");
	vfieldBinSize=pt.get<double>("GeneralParameters.vfieldBinSize");
	
	dt=pt.get<double>("GeneralParameters.dt");
	tau=pt.get<double>("GeneralParameters.tau");
	drawInterval=pt.get<int>("GeneralParameters.drawInterval");
	triangulationInterval=pt.get<int>("GeneralParameters.triangulationInterval");
	thermostat=pt.get<std::string>("GeneralParameters.thermostat");
	
	// channnel disorder
	disorderDensity=pt.get<double>("GeneralParameters.disorderDensity");
	disorderStrength=pt.get<double>("GeneralParameters.disorderStrength");
	disorderRange=pt.get<double>("GeneralParameters.disorderRange");
	
	
	version.set_versionStr(pt.get<std::string>("meshworks.version"));
	
	std::cout << "   Job header loadeded.\n\n";
 
	
}

void CSimulation::readSingleDataStep()
{
	
	CVersion reqVersion;
	reqVersion.set_versionStr("2.1.0");
	if (version<reqVersion)
	{	
		//std::cout << "old" << std::endl;
		readSingleDataStep_old();
		return;
		
	}  
	//else std::cout << "new" << std::endl;	
			
	
	static std::ifstream readStepDataFile;
	
	if (!readStepDataFile.is_open())
	{
		std::ostringstream jobstr;
		jobstr.str("");
		jobstr << jobnum << "//guidata.txt"; 
	
		readStepDataFile.open(jobstr.str().c_str());
		std::cout << "Opening guidata file...";	
	}
	
	std::string temp;
	std::string input;
	std::string in;
	std::string in2;
	std::string tline;
	std::string vortline;
	int timestep;
	int numVortices;
	std::stringstream sinput;
	
	double xval;
	double yval;
	int coord_num;
	double a0;
				
							
	if (readStepDataFile.is_open() && readStepDataFile.good()) 
	{
		// read timestep header
	
		std::getline(readStepDataFile, input);
		
		sinput.str("");
		sinput << input;
		sinput >> in >> timestep >> in2 >> numVortices;
		
		//std::cout << in << " " << timestep << " " << in2 << " " << numVortices << std::endl;
		
		
		for (int i =1;i<=numVortices;i++)
		{
			
			std::getline(readStepDataFile, input);
		
				
			if (get_draw())
			{
				
				
				std::stringstream tinput;
				tinput << input;
				tinput >> xval >> yval >> coord_num >> a0;
				
		
				// add new vortex
				CParticle newVortex;
				newVortex.set_pos(xval,yval);
				newVortex.set_coord_num(coord_num);
				newVortex.set_a(a0);
				vorticesList.push_back(newVortex);
			}
			
		}
		
	
	}
	
	//std::cout << "readSingleDataStep() loaded " << vorticesList.size() << " vortices." << std::endl;
}


void CSimulation::readSingleDataStep_old()
{

	static std::ifstream readStepDataFile;

	if (!readStepDataFile.is_open())
	{
		std::ostringstream jobstr;
		jobstr.str("");
		jobstr << /*ini.readDataLocation <<*/ jobnum << "//guidata.txt";

		char renderChar[100];
		std::string renderStr;
		renderStr = jobstr.str();
		strcpy(renderChar,renderStr.c_str());

		readStepDataFile.open(renderChar);
		std::cout << "Opening guidata file...";	
	}



	if (readStepDataFile.is_open())
	{

		std::string input;
		std::string input2;
		double xval;
		double yval;
		int coord_num;

		double a0double;
		std::string timeline ("timestep");
		std::string nan ("nan");
		std::string inf ("INF");
		size_t found;
		static bool first = true;
		bool endofstep=false;

		while ( readStepDataFile.good() && endofstep==false)
		{

			readStepDataFile >> input;
			found = input.find(timeline);

			if (found==std::string::npos)
			{
				bool nanFound= false;
				// add new points to delVortexList
				// converts first to double
				//if (t>4000) cout << input << " ";
				if (input.find("INF")==std::string::npos || input2.find("nan")==std::string::npos)
				{
					char charinput[256];
					strcpy(charinput, input.c_str());
					xval = atof (charinput);
				}
				else nanFound=true;

				// reads next three into strings, check if numnber
				// then converts to double
				readStepDataFile >> input2;
				//if (t>4000) cout << input2 << " ";
				if (input2.find("INF")==std::string::npos || input2.find("nan")==std::string::npos )
				{
					char charinput[256];
					strcpy(charinput, input2.c_str());
					yval = atof (charinput);
				}
				else nanFound=true;

				readStepDataFile >> input2;
				//if (t>4000) cout << input2 << " ";

				if (input2.find("INF")==std::string::npos || input2.find("nan")==std::string::npos)
				{
					char charinput[256];
					strcpy(charinput, input2.c_str());
					coord_num = (int)atof (charinput);
				}
				else nanFound=true;

				readStepDataFile >> input2;
				//if (t>4000) cout << input2 << " " << endl;

				if (input2.find("INF")==std::string::npos || input2.find("nan")==std::string::npos)
				{
					char charinput[256];
					strcpy(charinput, input2.c_str());
					a0double = atof (charinput);
				}
				else nanFound=true;


				//cout << yval << endl;

				if (nanFound==false)
				{	
					//cout << "Found coordinates" << endl;
					// add new vortex
					CParticle newVortex;
					newVortex.set_pos(xval,yval);
					newVortex.set_coord_num(coord_num);
					newVortex.set_a(a0double);
					vorticesList.push_back(newVortex);



				}
				else
				{
					std::cout << "nan" << std::endl;
				}	


			}
			else if (found!=std::string::npos)
			{ // found line containing timestep
				//cout << "input: " << input << endl;
				if (first==true)
				{
					first=false;
				}
				else
				{
					//cout << "End of read step" << endl;
					//cout << delVortexList.size() << endl;
					endofstep=true;

				}

			}

		}


	}

	//std::cout << "readSingleDataStep() loaded " << vorticesList.size() << " vortices." << std::endl;
}

void CSimulation::end_simulation()
{
	t= simulation_time;
	running=false;
	
}

std::string CSimulation::get_normaliseSourceStr() const
{
	return normaliseSourceStr;
	
}

std::string CSimulation::get_normaliseSinkStr() const
{
	return normaliseSinkStr;
	
}

bool CSimulation::is_paused() const
{
	return paused;
}

void CSimulation::pause_simulation()
{
	paused=true;
}

void CSimulation::unpause_simulation()
{
	paused=false;
}

void CSimulation::calculateBinnedBfield() {
	// This routine calculates the effective B field of channel && source && sink using
	// the binned method (does not include the wings)
	
	std::ostringstream oss;
	oss.str("");
	oss.precision(5);
	std::vector<CBin> BfieldBinVector (numBins);
	int bin;
	
	static std::vector<CBin> BfieldBinVectorSum (numBins);
	int bincount=0;
		
	if (0==t%triangulationInterval) {
	
	for (std::list<CDelLine>::iterator p = delLinesList.begin();
				p!=delLinesList.end(); ++p) {
		double midy = (p->get_y1() + p->get_y2())/2.0;
		double midx = (p->get_x1() + p->get_x2())/2.0;
						
		if (midy>0 && midy<channelWidth) {
			//continue;
			double linelength=std::sqrt((double) (p->get_x1()-p->get_x2())*(p->get_x1()-p->get_x2())
																		+ (p->get_y1()-p->get_y2())*(p->get_y1()-p->get_y2()));
			
			bin = (int)floor((midx+binsize/2.0)* (numBins/(urectx1-urectx0)));
					//vxbin = bin;   // for vxfile
			BfieldBinVector[bin].set_val(linelength);
					
	
		}

	}
	
			
	for (std::vector<CBin>::iterator p = BfieldBinVector.begin();
			p!= BfieldBinVector.end(); ++p ) {

			oss<< std::setw(10) << binsize/2.0+urectx0+bincount*binsize;
			bincount++;
			
				
	}
	calculateBinnedBfieldStr1=oss.str();
	
	oss.str("");
	
	bincount=0;
		for (std::vector<CBin>::iterator p = BfieldBinVector.begin();
			p!= BfieldBinVector.end(); ++p ) {
			double Beff=2*Phi/(std::sqrt((double)3)*p->get_val()*p->get_val());		
			if (boost::math::isinf((double)(Beff))) oss << std::setw(10) << "-";
			else oss<<  std::setw(10) << Beff;
			bincount++;
			BfieldBinVectorSum[p-BfieldBinVector.begin()].set_val(Beff);
		  
				
	}
	

	calculateBinnedBfieldStr2=oss.str();
	}
	
	Bfieldfile << t << std::endl << calculateBinnedBfieldStr1 << std::endl << calculateBinnedBfieldStr2 << std::endl;
	
	
	if (t==simulation_time) {
	// output in csv format
				
		bincount=0;
		for (std::vector<CBin>::iterator p = BfieldBinVectorSum.begin();
				p!= BfieldBinVectorSum.end(); ++p ) {
				  
			averagedBfielddata<<  binsize/2.0+urectx0+bincount*binsize  << "," << p->get_val() << std::endl;
			bincount++;
					
		}
	}
	
	
	
	
	
}

std::string CSimulation::get_calculateBinnedBfieldStr1() const
{
	return calculateBinnedBfieldStr1;
}
	
std::string CSimulation::get_calculateBinnedBfieldStr2() const
{
	return calculateBinnedBfieldStr2;
}


void CSimulation::iniread_JobBatchFile() 
{
	std::cout << "Loading job batch file..." << std::endl;
	std::cout << "   from " << jobBatchFileLocation << std::endl;
	boost::property_tree::ptree pt;
	boost::property_tree::ini_parser::read_ini(jobBatchFileLocation, pt);
	
	// geometry variables
	a0= pt.get<double>("GeneralParameters.a0");
	b0=(std::sqrt((double)3)/2.0)*a0;
	
	// analysis variables
	binsize=pt.get<double>("GeneralParameters.binSize");
		
	// physics variables and constants
	pi=pt.get<double>("GeneralParameters.pi");
	Phi=pt.get<double>("GeneralParameters.Phi");
	forceRange=pt.get<double>("GeneralParameters.forceRange");
	eta=pt.get<double>("GeneralParameters.eta");
	kB=pt.get<double>("GeneralParameters.kB");
	mu0=pt.get<double>("GeneralParameters.mu0");
	lambda=pt.get<double>("GeneralParameters.lambda");
	Ap=pt.get<double>("GeneralParameters.Ap");
	
	// simulation variables
	cellSize=pt.get<double>("GeneralParameters.cellSize");
	vfieldBinSize=pt.get<double>("GeneralParameters.vfieldBinSize");
	
	dt=pt.get<double>("GeneralParameters.dt");
	tau=pt.get<double>("GeneralParameters.tau");
	drawInterval=pt.get<int>("GeneralParameters.drawInterval");
	triangulationInterval=pt.get<int>("GeneralParameters.triangulationInterval");
	drawCoordinateGrid=pt.get<bool>("GeneralParameters.drawCoordinateGrid");
	calcTrajectories=pt.get<bool>("GeneralParameters.calcTrajectories");
	
	thermostat=pt.get<std::string>("GeneralParameters.thermostat");
	
	// channnel disorder
	disorderDensity=pt.get<double>("GeneralParameters.disorderDensity");
	disorderStrength=pt.get<double>("GeneralParameters.disorderStrength");
	disorderRange=pt.get<double>("GeneralParameters.disorderRange");
	
	// Job header section
	
	runtype=pt.get<int>("Header.runtype");
	outputtype=pt.get<int>("Header.outputtype");
		
	geometry=pt.get<int>("Header.geometry");
		
	if (periodic==geometry)
	{
		Bfield=pt.get<double>("Header.Bfield");
	}
	else
	{
		sourceBfield=pt.get<double>("Header.sourceBfield");
		sinkBfield=pt.get<double>("Header.sinkBfield");
	
		bathLength=pt.get<double>("Header.bathLength")*a0;
	}
	
	if (channel==geometry) bathWidth=pt.get<double>("Header.bathWidth")*b0;
	
	channelLength=pt.get<double>("Header.channelLength")*a0;
	channelWidth=pt.get<double>("Header.channelWidth")*b0;
	
	if (tube==geometry) bathWidth=channelWidth; 
	
	simulation_time=pt.get<double>("Header.simulationTime");
	
	temp=pt.get<double>("Header.temp");  
	lorentzForce=pt.get<double>("Header.lorentzForce");  
	
	jobtag=pt.get<std::string>("Job.jobtag");  
	
	
	std::cout << "   Job Header loaded.\n\n";
	
}

void CSimulation::configure_simulation()
{
	
	if (periodic==geometry)
	{
		channelOffset=0;
	}
	else channelOffset = (bathWidth-channelWidth)/2.0;
	
	//cellSize=5*a0;
	
	 
	etchsourcex0 =0; 
    etchsourcey0= -channelOffset;
    etchsourcex1 =bathLength-0.1*a0; 
    etchsourcey1= channelWidth+channelOffset;
    
    etchsinkx0 =bathLength+channelLength+0.1*a0; 
    etchsinky0= -channelOffset;
    etchsinkx1 =bathLength+channelLength+bathLength; 
    etchsinky1= channelWidth+channelOffset;
    
    etchchannelx0=0;
    etchchannely0=0;
    etchchannelx1=bathLength+channelLength+bathLength;
    etchchannely1=channelWidth;
    
    removesourcex=-a0/2;
    removesinkx=bathLength+channelLength+bathLength+a0;
    removesourcey0=-channelOffset-b0;
    removesourcey1=channelWidth+channelOffset+b0;
  
	removechannelx0=bathLength+a0/2;
	removechannelx1=bathLength+channelLength-a0/2;
	
	removetopchannely=-b0;
	removebottomchannely=channelWidth+b0;
	
	
	urectx0 = -binsize/2.0;
	urecty0 = channelWidth/2.0-a0;
	urectx1 = 2*bathLength+channelLength+binsize/2.0;
	urecty1 = channelWidth/2.0+a0;
	
	
	/* due to etch process any even channel width has the bottom row of pins at -b0.
	 * Since the weff=channelWidth+b0 this puts the top row of pins at channelWidth+b0/2.
	 * 
	 * 
	 */ 
	
	bulkx0=0;
	bulkx1=2*bathLength+channelLength;
	bulky0=0; 
	bulky1=channelWidth-b0/2;
  
  
	dislocationx0=bathLength;
	dislocationx1=bathLength+channelLength;
	dislocationy0=0;//1.1*a0;
	dislocationy1=channelWidth;//channelHeight-1.1*a0;
	
	// more analysis variables (requires urect...)
	numBins = (int)ceil((urectx1-urectx0)/binsize);
		
	// physics
	f0=-Phi*Phi/(2.0*pi*mu0*lambda*lambda*lambda);	
	
	if (channel==geometry)
	{
		sourceDensity=(int)(bathLength*bathWidth*sourceBfield/Phi); 
		sinkDensity=(int)(bathLength*bathWidth*sinkBfield/Phi); 
		channelDensity=(int)(channelLength*(channelWidth+b0)*((sourceBfield+sinkBfield)/Phi)/2.0); 	
	}
	else if (tube==geometry)
	{
		sourceDensity=(int)(bathLength*(channelWidth)*sourceBfield/Phi); 
		sinkDensity=(int)(bathLength*(channelWidth)*sinkBfield/Phi); 
		channelDensity=(int)(channelLength*(channelWidth+b0)*((sourceBfield+sinkBfield)/Phi)/2.0); 	
	}
	else if (periodic==geometry)
	{
		channelDensity=(int)(channelLength*(channelWidth)*((Bfield)/Phi)); 	
	}
	
	
}

double CSimulation::get_M2() const
{
	return M2;
}

double CSimulation::get_M2Average() const
{
	return M2Sum/(double)t;
}

double CSimulation::get_M2Full() const
{
	return M2Full;
}

double CSimulation::get_M2FullAverage() const
{
	return M2FullSum/(double)t;
}


double CSimulation::get_temp() const
{
	return temp;
}

double CSimulation::get_A() const 
{
	return A;
}

double CSimulation::get_ratioOfDefects() const 
{
	return (double)Nmis/(double)Nv;
}


double CSimulation::AndersonTS()
{
	double p=dt/tau;
	if (p>rand()/(double)RAND_MAX)
	{	
		
		return sqrt(2*temp*kB*dt/eta/p)*gen_normal_3(generator);
	}
	else
	{
		return 0;
			
	}
}

double CSimulation::LindemanTS() const
{
	return sqrt((double)temp)*gen_normal_3(generator);
	
}

std::string CSimulation::get_thermostat() const
{
	return thermostat;
	
}

void CSimulation::initialiseChannelDisorder()
{
	std::cout << "Initialising channel disorder..." << std::endl;
	
	std::cout << "   Number of Gaussian pins per a0^2: " << disorderDensity << std::endl;
	
	double numberChannelPins=channelLength*channelWidth*disorderDensity/a0/a0;	
	std::cout << "   Number of Gaussin pins in this channel: " << numberChannelPins << std::endl;
	
	std::cout << "   Disorder strength: " << disorderStrength << std::endl;
	std::cout << "   Disorder range: " << disorderRange << std::endl;
	
	
	for (int i=0; i< numberChannelPins;i++)
	{
		double x=bathLength+channelLength*(rand()/(double)RAND_MAX);
		double y=channelWidth*(rand()/(double)RAND_MAX);
		CPin newPin(x,y,disorderStrength,disorderRange);
		disorderVector.push_back(newPin);
	}
	
		
	
	
	std::cout << "   Channel disorder initialised." << std::endl << std::endl;
}

void CSimulation::calculateFinishTime()
{
	
	if (0==t%100)
	{
		double newtime=time(0);
		MonitorPeriod=newtime-lasttime;
		lasttime=newtime;
	}
	
	//if (0==t%drawInterval)
	//{
		double hours = floor(MonitorPeriod*(simulation_time-t)/100.0/60.0/60.0);
		double minutes = (int)(MonitorPeriod*(simulation_time-t)/100.0/60.0)%60;
		std::ostringstream oss;
		oss << "Estimated finish time : " << hours << "h " << minutes << "m";
		finishTimeStr = oss.str();
	
	if (0==t%100) std::cout << finishTimeStr << std::endl;
	

	
	
}

std::string CSimulation::get_finishTimeStr() const
{
	return finishTimeStr;
	
}

void CSimulation::calculateAvVel()
{
	/*
	 *   calculates the space and time average of the x and y velocities of the channel vortices.
	 * 	 Works for both channel system and tube system.
	 *   channel vortices are defined as not source or sink vortices.
	 *   
	 *   Current avYVel= Sum (Over t) [Sum (All channel vortices)->vely]/num channel vortices ;
	 *   To get time and space average divide by t
	 * 
	 * 	 same for x
	 */ 
	double spaceSumX=0;
	double spaceSumY=0;
	int count=0;
	for(std::list<CParticle>::iterator p = vorticesList.begin();
	    p != vorticesList.end(); p++)
	{
		if (p->get_x()>=bathLength && p->get_x() <=bathLength+channelLength)
		{
			count++;
			spaceSumX=spaceSumX+p->get_velx();
			spaceSumY=spaceSumY+p->get_vely();
			
		}
		
	}
	avXVel=avXVel+spaceSumX/(double)count;
	avYVel=avYVel+spaceSumY/(double)count;
	
}

double CSimulation::get_tAvSAvVelY() const 
{
	/*	
	 * Returns time and space average of vely of channel vortices
	 * 
	 */
	 	 
	return avYVel/(double)t;
	
}

double CSimulation::get_tAvSAvVelX() const 
{
	/*	
	 * Returns time and space average of velx of channel vortices
	 * 
	 */
	 	 
	return avXVel/(double)t;
	
}


void CSimulation::initialiseVorticesPeriodic()
{
	
	std::cout << "Initialising Vortices (Periodic)..." << std::endl;
	std::cout << "   " << "channelDensity: " << channelDensity << std::endl;
	
	
	std::ostringstream oss;
	char renderChar[100];
	std::string renderStr;
	
	oss.str("");
	oss << "startdataMesh//P-" << Bfield << "-" <<  channelLength/a0 << "x" << channelWidth/b0 << ".txt";
	
	std::cout << "   " << oss.str() << std::endl;
	
	std::ifstream myfile (oss.str().c_str());
	
	
	if (myfile.is_open()) 
	{
		std::cout << "   " << "Initial Vortex Positions From File" << std::endl;
		
		double xval;
		double yval;
	
		while ( myfile.good() )
		{
			myfile >> xval;
			myfile >> yval;
		
			CParticle newVortex;
			newVortex.set_pos(xval,yval);
			vorticesList.push_back(newVortex);
	
		}
		myfile.close();
	
	}
	else
	{
		std::cout << "   " << "no start data" << std::endl;
		
		for (int i = 0; i<(channelDensity);i++)
		{
			double xval = channelLength*(rand() % 1000)/1000.0;
			double yval = channelWidth*(rand() % 1000)/1000.0;
			
			
			CParticle newVortex;
			newVortex.set_pos(xval,yval);
			vorticesList.push_back(newVortex);
			
		}	
	
	
	
	
	}
	
	std::cout << "   " << "initialiseVorticesPeriodic() created " << vorticesList.size() << " vortices." << std::endl << std::endl;
}


void CSimulation::removeEscapedVorticesPeriodic() {
  
  std::list<CParticle>::iterator p = vorticesList.begin();
  

  
  
	while (p != vorticesList.end()) {
		bool removed=false;
		/*if (p->get_x() <= removefunnelx) {
			cout << "Removed at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << endl;  
			p=vorticesList.erase(p);
			//p--;
			removed=true;
			
		}
		else if (p->get_y() <= -funnelWidth*tan(funnelAngle)-2*b0 || p->get_y() >= funnelWidth*tan(funnelAngle)+channelHeight+2*b0) {
			cout << "Removed at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << endl;  
			p=vorticesList.erase(p);
			//p--;
			removed=true;
		
		}
		else*/
		/*if (p->get_x() <= removesourcex)
		{
			std::cout << "Removed at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p=vorticesList.erase(p);
			//p--;
			removed=true;
			
		}
		else if (p->get_x() >= removesinkx)
		{
			std::cout << "Removed at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p=vorticesList.erase(p);
			//p--;
			removed=true;
			
		} */
		
		/* else if ((p->get_y() <= removesourcey0) and  (p->get_x() < removechannelx0 ) )  {
			cout << "wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << endl;  
			//p=vorticesList.erase(p);
			p->set_pos(p->get_x(),p->get_y()+channelHeight+b0);
			//p--;
			//removed=true;
		
		} else if ((p->get_y() > removesourcey1) and  (p->get_x() < removechannelx0) )  {
			cout << "wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << endl;  
			//p=vorticesList.erase(p);
			p->set_pos(p->get_x(),p->get_y()-channelHeight-b0);
			//p--;
			//removed=true;
		
		}*/
		 //else 
		 if ((p->get_y() <= 0))  {
			std::cout << "wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p->set_pos(p->get_x(),p->get_y()+channelWidth);
			//p=vorticesList.erase(p);
			//p--;
			//removed=true;
		} else if ((p->get_y() >= channelWidth))  {
			std::cout << "wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p->set_pos(p->get_x(),p->get_y()-channelWidth);
			//p=vorticesList.erase(p);
			//p--;
			//removed=true;
		}
		 else if ((p->get_x() <= 0))  {
			std::cout << "wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p->set_pos(p->get_x()+channelLength,p->get_y());
			//p=vorticesList.erase(p);
			//p--;
			//removed=true;
		}  else if ((p->get_x() >= channelLength) )  {
			std::cout << "wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p->set_pos(p->get_x()-channelLength,p->get_y());
			//p=vorticesList.erase(p);
			//p--;
			//removed=true;
		}
		
		
		
		
		/*else if ((p->get_y() <= -fabs(p->get_x())*tan(funnelAngle) ) &&  (p->get_x() < removesourcex) )  {
			cout << "funnel wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << std::endl;  
			p->set_pos(p->get_x(),p->get_y()+channelHeight+b0+2.0*p->get_x()*tan(funnelAngle));
			//p=vorticesList.erase(p);
			//p--;
			//removed=true;
		}  else if ((p->get_y() >= channelHeight+b0+fabs(p->get_x())*tan(funnelAngle)) &&  (p->get_x() < removesourcex) )  {
			cout << "funnel wrapped at " << t << " pos (" <<  p->get_x() << ", " << p->get_y() << ") vel (" << p->get_velx() << ", " << p->get_vely() << ")" << endl;  
			p->set_pos(p->get_x(),p->get_y()-channelHeight-b0-2.0*p->get_x()*tan(funnelAngle));
			//p=vorticesList.erase(p);
			//p--;
			//removed=true;
		}*/
		
		
		
		
		
		
	
	
	
		if (removed==false) { ++p; }
	
	}
}

void CSimulation::wrapVorticesPeriodic(std::list<CParticle>& vorticesList_)
{
	std::list<CParticle> wrappedVorticesList;
	wrappedVorticesList=vorticesList_;
	
	for (std::list<CParticle>::iterator p = vorticesList_.begin();
		p!=vorticesList_.end(); ++p )
	{
		// wrap vortices on tube
		//if (p->get_x() >=0) {
			if (p->get_y() <= forceRange)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()+channelWidth);
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			else if (p->get_y() >= channelWidth-forceRange)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()-channelWidth);
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			if (p->get_x() <= forceRange)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x()+channelLength,newVortex.get_y());
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			else if (p->get_x() >= channelLength-forceRange)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x()-channelLength,newVortex.get_y());
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			
			// corners
			if (p->get_y() <= forceRange && p->get_x() <=forceRange)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x()+channelLength,newVortex.get_y()+channelWidth);
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			else if (p->get_y() >= channelWidth-forceRange && p->get_x() >= channelLength-forceRange)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x()-channelLength,newVortex.get_y()-channelWidth);
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			else if (p->get_y() <= forceRange && p->get_x() >= channelLength-forceRange)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x()-channelLength,newVortex.get_y()+channelWidth);
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			else if (p->get_y() >= channelWidth-forceRange && p->get_x() <= forceRange)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x()+channelLength,newVortex.get_y()-channelWidth);
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			
			
			
			
			
			
			
		//}
		
		/*else if (p->get_x() < 0) {  // wrap vortices on cone
			if (p->get_y() <= -fabs(p->get_x())*tan(funnelAngle)+forceRange) {
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()+channelHeight+b0+2.0*fabs(p->get_x())*tan(funnelAngle) );
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			else if (p->get_y() >= channelHeight+fabs(p->get_x())*tan(funnelAngle)-forceRange) {
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()-channelHeight-b0-2.0*fabs(p->get_x())*tan(funnelAngle));
				newVortex.set_ghost();
				wrappedVorticesList.push_back(newVortex);
			}
			
		}*/
	}
	
	vorticesList_=wrappedVorticesList;

}


void CSimulation::analyseDataPeriodic()
{
		/*	Analysis of periodic simulation run
		 * 
		 * 	List of outputs
		 * 		
		 * 		Density of defects
		 *    Final Vortex Positions to file
		 */
		
		calculateRatioOfDefectsPeriodic();
	
		outputFinalVortexPositions();
	
}


void CSimulation::calculateRatioOfDefectsPeriodic()
{
	ratioOfDefects=0;
	Nv=0;
	Nmis=0;
	for (std::list<CParticle>::iterator p = delVortexList.begin();
		p!=delVortexList.end(); ++p)
	{
		if (false==p->get_ghost())
		{
			Nv++;
			
			if (6!=p->get_coord_num())
			{
				Nmis++;
			}
			
		} 
		
	}
	ratioOfDefects=Nmis/(double)Nv;
	
}

int CSimulation::get_Nv() const
{
	return Nv;
	
}

void CSimulation::calculateRatioOfDefects()
{
	ratioOfDefects=0;
	Nv=0;
	Nmis=0;
	for (std::list<CParticle>::iterator p = delVortexList.begin();
		p!=delVortexList.end(); ++p)
	{
		if (p->get_x() <bathLength || p->get_x()>bathLength+channelLength) continue;
			if (false==p->get_ghost())
			{
				Nv++;
				
				if (6!=p->get_coord_num())
				{
					Nmis++;
				}
				
			} 
			
	}
	ratioOfDefects=Nmis/(double)Nv;
	
}

void CSimulation::outputFinalVortexPositions()
{
	// At the end of the simulation, output vortex positions
	if (t==simulation_time)
	{
		// output all vortex positions	
		//if (DEBUG) posfile << "Time: " << t << endl;
		
		for(std::list<CParticle>::iterator p = vorticesList.begin();
			p != vorticesList.end(); ++p)
		{
			posfile << std::setw(20) << p->get_x() << std::setw(20) << p->get_y();
			
			if ( std::distance(p,vorticesList.end()) != 1 )
			{
				posfile << std::endl;
			}
		}
		
	}
}

void CSimulation::outputForces()
{
	//output forces
	forcesfile << "   " <<  "timestep:" << t << std::endl;
	for(std::list<CParticle>::iterator p = vorticesList.begin();
		p != vorticesList.end(); ++p)
	{
		forcesfile << std::setw(20) << p->get_forcex() << std::setw(20) << p->get_forcey() 
							 << std::setw(20) << p->get_velx() << std::setw(20) << p->get_vely() << std::endl;
		
		
	}
	
	
}

void CSimulation::outputAverages()
{
	if (simulation_time==t)
	{
		avfile << "Time and space averaged quantities" << std::endl
					 << "  velx of channel vortices: " << get_tAvSAvVelX() << std::endl
					 << "  vely of channel vortices: " << get_tAvSAvVelY() << std::endl
					 << "  M2 (just stochastic term): " << get_M2Average() << std::endl
					 << "  M2 (all terms): " << get_M2FullAverage() << std::endl;
	
	}
	
}

bool CSimulation::get_drawCoordinateGrid() const
{
	return drawCoordinateGrid;
	
}

bool CSimulation::get_drawSixFold() const
{
	return !triangulateReadRun;
	
}

int CSimulation::get_runtype() const
{
	return runtype;

}

int CSimulation::what_icell(CParticle a_) const
{
	double i= floor((a_.get_x()-get_firstPin().get_x())/cellSize);
	//std::cout << i << "  ";
	if (i<0) return 0;
	else return i;

}

int CSimulation::what_jcell(CParticle a_) const
{
	double j= floor((a_.get_y()-get_firstPin().get_y())/cellSize);
	//std::cout << j << "  ";
	if (j<0) return 0;
	else return j;

}

int CSimulation::what_ivfieldBin(CParticle a_) const
{
	double i= floor((a_.get_x()-get_firstPin().get_x())/vfieldBinSize);
	//std::cout << i << "  ";
	if (i<0) return 0;
	else return i;

}

int CSimulation::what_jvfieldBin(CParticle a_) const
{
	double j= floor((a_.get_y()-get_firstPin().get_y())/vfieldBinSize);
	//std::cout << j << "  ";
	if (j<0) return 0;
	else return j;

}


void CSimulation::delaunayTriangulation_old(/*list<CParticle>::iterator& corner, */std::list<CParticle> vorticesList_/*, list<CParticle>& delVortexList, list<CParticle>& pinsList, list<CDelLine>& delLinesList, list<CDelTriangle>& delTrianglesList*/) {
	
	//std::cout << "Start Triangulation" << std::endl;
	//add edge of pins list to vortices list
	
	for(std::list<CParticle>::iterator p=pinsList.begin();
			p!=pinsList.end();p++){
		if (  p->get_x() > etchchannelx0 && p->get_x() < etchchannelx1
			  && p->get_y() > etchchannely0-a0 && p->get_y() < etchchannely1+a0 ){
				(*p).set_ghost();	
			vorticesList_.push_back(*p);
		}
	}
	
	// wrap vortices for correct triangulation in tube
	if (tube==geometry)
	{
		for (std::list<CParticle>::iterator p = vorticesList.begin();
			p!=vorticesList.end(); ++p )
		{
			if (p->get_y() <= 2*b0)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()+channelWidth+b0);
				newVortex.set_ghost();
				vorticesList_.push_back(newVortex);
			}
			else if (p->get_y() >= channelWidth-2*b0)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()-channelWidth-b0);
				newVortex.set_ghost();
				vorticesList_.push_back(newVortex);
			}
		
		}
		
		
	}
	else if (periodic==geometry)
	{
		/*for (std::list<CParticle>::iterator p = vorticesList.begin();
			p!=vorticesList.end(); ++p )
		{
			if (p->get_y() <= 2*b0)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()+channelWidth);
				newVortex.set_ghost();
				vorticesList_.push_back(newVortex);
			}
			else if (p->get_y() >= channelWidth-2*b0)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x(),newVortex.get_y()-channelWidth);
				newVortex.set_ghost();
				vorticesList_.push_back(newVortex);
			}
			if (p->get_x() <= 2*a0)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x()+channelLength,newVortex.get_y());
				newVortex.set_ghost();
				vorticesList_.push_back(newVortex);
			}
			else if (p->get_x() >= channelLength-2*a0)
			{
				CParticle newVortex;
				newVortex = (*p);
				newVortex.set_pos(newVortex.get_x()-channelLength,newVortex.get_y());
				newVortex.set_ghost();
				vorticesList_.push_back(newVortex);
			}
		}*/
		wrapVorticesPeriodic(vorticesList_);
		
	}
	
	
	
	std::list<CDelLine> allEdges;
	std::list<CDelLine> uniqueEdges;	
	std::set<CCoord> uniquePoints;
		
	// add p_{-1} && p_{-2}
	delVortexList.clear();
	delLinesList.clear();
	delTrianglesList.clear();
	CParticle pminus2;
	
	CParticle pminus1;
	CCoord t0,t1, t2;  //corners of large triangle
	
	if (periodic==geometry)
	{
		t0.set_coords(-5*a0,-channelWidth);
		t1.set_coords(-5*a0,100*channelWidth);
		t2.set_coords((channelLength)*100,-channelWidth);
	}
	else
	{
		t0.set_coords(-5*a0,-bathWidth);
		t1.set_coords(-5*a0,100*channelWidth);
		t2.set_coords((2*bathLength+channelLength)*100,-bathWidth);
	}
	
	pminus2.set_pos(t2.get_x(),t2.get_y());
	pminus1.set_pos(t1.get_x(),t1.get_y());
	
	delVortexList.push_back(pminus2);
	delVortexList.push_back(pminus1);
	
	CParticle p0;
	
	p0.set_pos(t0.get_x(),t0.get_y());
		
	delVortexList.push_back(p0);
	//corner= delVortexList.end();
	//--corner;
	
	//drawlines list
	CDelLine newDelLine;
	newDelLine.set_points(t0.get_x(),t0.get_y(),t2.get_x(),t2.get_y());
	delLinesList.push_back(newDelLine);	
	
		
	newDelLine.set_points(t2.get_x(),t2.get_y(),t1.get_x(),t1.get_y());
	delLinesList.push_back(newDelLine);	
	
	
	newDelLine.set_points(t1.get_x(),t1.get_y(),t0.get_x(),t0.get_y());
	delLinesList.push_back(newDelLine);	
	
	
	
	// add new delTriangle
	CDelTriangle newDelTriangle;
	newDelTriangle.set_vertices(t0.get_x(),t0.get_y(),
															t2.get_x(),t2.get_y(),
															t1.get_x(),t1.get_y());
	newDelTriangle.set_finalDaughter(false);
	delTrianglesList.push_back(newDelTriangle);
	
	
	// choose next vortex from vorticesList to add to the Delaunay Triangulation
	
	
	
	for (std::list<CParticle>::iterator q = vorticesList_.begin();
			q!=vorticesList_.end();++q) {	
		//if (q->get_x()>sourceWidth+latticeSpacing/2.0 && q->get_x() <sourceWidth+channelWidth-latticeSpacing/2.0 ) {
	
		std::list<CDelTriangle>::iterator p=delTrianglesList.begin();
		
		
		allEdges.clear();
		uniqueEdges.clear();
		
		while (p!=delTrianglesList.end()) {
			if (circum(p,q)>0) 
			{
			
				// add three edges to the list of edges affected
				CDelLine addedge;
				
				addedge.set_points(p->get_Ax(),p->get_Ay(),p->get_Bx(),p->get_By());
				allEdges.push_back(addedge);
				addedge.set_points(p->get_Bx(),p->get_By(),p->get_Cx(),p->get_Cy());
				allEdges.push_back(addedge);
				addedge.set_points(p->get_Cx(),p->get_Cy(),p->get_Ax(),p->get_Ay());
				allEdges.push_back(addedge);
				
				// remove illegal lines
				
				std::list<CDelLine>::iterator r=delLinesList.begin();
				
				while(r!=delLinesList.end()){
					if( 	(	r->get_x1()==p->get_Ax() && r->get_y1()==p->get_Ay() 
							&& r->get_x2()==p->get_Bx() && r->get_y2()==p->get_By() )
							
							||
							(	r->get_x1()==p->get_Bx() && r->get_y1()==p->get_By() 
							&& r->get_x2()==p->get_Ax() && r->get_y2()==p->get_Ay() )
							)
							
							 {
						r=delLinesList.erase(r);
						
							
					}
					else if(( 	r->get_x1()==p->get_Bx() && r->get_y1()==p->get_By() 
							&& r->get_x2()==p->get_Cx() && r->get_y2()==p->get_Cy() )
							||
							( 	r->get_x1()==p->get_Cx() && r->get_y1()==p->get_Cy() 
							&& r->get_x2()==p->get_Bx() && r->get_y2()==p->get_By() )
							)
							 {
								
						r=delLinesList.erase(r);
						
							
					}
					else if(( 	r->get_x1()==p->get_Cx() && r->get_y1()==p->get_Cy() 
							&& r->get_x2()==p->get_Ax() && r->get_y2()==p->get_Ay() )
							||
							(  	r->get_x1()==p->get_Ax() && r->get_y1()==p->get_Ay() 
							&& r->get_x2()==p->get_Cx() && r->get_y2()==p->get_Cy()  )
												
							) {
						r=delLinesList.erase(r);
						
					}
					else {
						++r;
					}
							
					
				}
				
				// remove triangle
				
				p=delTrianglesList.erase(p);
				
				
				
			}
			else {
				++p;
			}
			
			
		
		}
		//remove all double edges from edgebuffer,keeping only unique ones
		bool doubleEdge;
		for (std::list<CDelLine>::iterator r= allEdges.begin();
				r!=allEdges.end();++r) {
			doubleEdge=false;
			for (std::list<CDelLine>::iterator s= allEdges.begin();
					s!=allEdges.end();++s) {
				if (r!=s) {
					if ( 		(eqtest(r->get_x1(),s->get_x1()) && eqtest(r->get_y1(),s->get_y1()) && eqtest(r->get_x2(),s->get_x2()) && eqtest(r->get_y2(),s->get_y2()))
							||	(eqtest(r->get_x1(),s->get_x2()) && eqtest(r->get_y1(),s->get_y2()) && eqtest(r->get_x2(),s->get_x1()) && eqtest(r->get_y2(),s->get_y1()))	) {
						// duplicated line
						doubleEdge=true;
					}
				}	
			
			} 
			if (doubleEdge==false) {
				uniqueEdges.push_back(*r);
			}
			
			
		}
		//cout << "uniqueEdges Size: " << uniqueEdges.size() << endl;
		
		/*uniquePoints.clear();
		CCoord newCoord;*/
		
		// count unique points
		//double uniquePointsArray[50][2];
		//double firstInArray=false;
		//double secondInArray=false;
		
		
		
		// form new triangles && lines between edges && vertices and calculate coord num
		for (std::list<CDelLine>::iterator p = uniqueEdges.begin();
				p!=uniqueEdges.end();++p)
			{
					
				
				//form a new triangle between edge and vertex
				newDelTriangle.set_vertices(p->get_x1(),p->get_y1(),p->get_x2(),p->get_y2(),q->get_x(),q->get_y());
				delTrianglesList.push_back(newDelTriangle);
				
				//add new lines for sdl
				
				newDelLine.set_points(p->get_x1(),p->get_y1(),p->get_x2(),p->get_y2());
				delLinesList.push_back(newDelLine);	
	
				newDelLine.set_points(p->get_x2(),p->get_y2(),q->get_x(),q->get_y());
				delLinesList.push_back(newDelLine);	
		
				newDelLine.set_points(q->get_x(),q->get_y(),p->get_x1(),p->get_y1());
				delLinesList.push_back(newDelLine);	
				
			
				
				
			}
		
	
		delVortexList.push_back(*q);
		//}
		
	  
	}
	
	
	// check delLinesList for dupilcates
	std::list<CDelLine> uniqueLinesList;
	//CDelLine testLine;
	bool addLine;
	
	for (std::list<CDelLine>::iterator p = delLinesList.begin();
				p!=delLinesList.end();++p) {
		//testLine=*p;
		addLine=true;
		for (std::list<CDelLine>::iterator q = uniqueLinesList.begin();
				q!=uniqueLinesList.end();++q) {
			if (  
				(eqtest(p->get_x1(),q->get_x1()) && eqtest(p->get_y1(),q->get_y1()) && eqtest(p->get_x2(),q->get_x2()) && eqtest(p->get_y2(),q->get_y2())) ||
				(eqtest(p->get_x2(),q->get_x1()) && eqtest(p->get_y2(),q->get_y1()) && eqtest(p->get_x1(),q->get_x2()) && eqtest(p->get_y1(),q->get_y2()))
		
			
			  ) {
				addLine=false;
			}
		}
		if (addLine==true) {
			uniqueLinesList.push_back(*p);
		}
			
	}
	
	std::cout << "lines : " << uniqueLinesList.size() << std::endl;
	
	int numNeighbours=0;
	for (std::list<CParticle>::iterator p = delVortexList.begin();
			p!=delVortexList.end();++p) {
		
		numNeighbours=0;
		double a0Sum=0;
		for (std::list<CDelLine>::iterator q = uniqueLinesList.begin();
				q!=uniqueLinesList.end();++q) {
			
			if (   (eqtest( p->get_x(),q->get_x1()) && eqtest(p->get_y(),q->get_y1()))
							|| (eqtest(p->get_x(),q->get_x2()) && eqtest(p->get_y(),q->get_y2() )) ){
				  a0Sum += q->get_length();
					numNeighbours++;
			}
			
			
			
			
			
					
		}
	
		
		//cout << "Num Neighbours: " << numNeighbours << endl;
		p->set_coord_num(numNeighbours);
		p->set_a(a0Sum/((double)numNeighbours));
	}

	
	
	// remove initial traingle
	std::list<CDelLine>::iterator itLines = delLinesList.begin();
	while (itLines!=delLinesList.end()) {
		if (	   (  eqtest(itLines->get_x1(),t0.get_x()) && eqtest(itLines->get_y1(),t0.get_y()))
				|| ( eqtest(itLines->get_x2(),t0.get_x()) && eqtest(itLines->get_y2(),t0.get_y()) )
				
				|| ( eqtest(itLines->get_x1(),t2.get_x()) && eqtest(itLines->get_y1(),t2.get_y()) )
				|| ( eqtest(itLines->get_x2(),t2.get_x()) && eqtest(itLines->get_y2(),t2.get_y()) ) 
				
				|| ( eqtest(itLines->get_x1(),t1.get_x())  && eqtest(itLines->get_y1(),t1.get_y()))
				|| ( eqtest(itLines->get_x2(),t1.get_x())  && eqtest(itLines->get_y2(),t1.get_y()))
				
			) {
	
			itLines=delLinesList.erase(itLines);
		} else	{
			//cout  <<"line: " << itLines->get_x1() << ", " << itLines->get_y1() << " -->  " << itLines->get_x2() << ", " << itLines->get_y2() << endl;
		
			++itLines;
		}
			
	}
	
	// remove initial large triangle
	
	std::list<CParticle>::iterator d=delVortexList.begin();
	delVortexList.erase(d);
	
	d=delVortexList.begin();
	delVortexList.erase(d);
	
	d=delVortexList.begin();
	delVortexList.erase(d);
	
	
	// remove lines between baths and channel passing over the CE
	
	std::list<CDelLine>::iterator p = delLinesList.begin();
  
	if (channel==geometry) 
	{
		while (p != delLinesList.end())
		{
			bool removed=false;
		
			
			if ((p->get_x1() < bathLength && p->get_y1() < 0  &&  p->get_x2() > bathLength)
			|| (p->get_x2() < bathLength && p->get_y2() < 0  &&  p->get_x1() > bathLength))
			{
				p=delLinesList.erase(p);
				removed=true;	
			} 
			
			if ((p->get_x1() < bathLength && p->get_y1() > channelWidth+b0  &&  p->get_x2() > bathLength)
			|| (p->get_x2() < bathLength && p->get_y2() > channelWidth+b0  &&  p->get_x1() > bathLength)) 
			{
				p=delLinesList.erase(p);
				removed=true;	
			} 
			
			if ((p->get_x1() > bathLength+channelLength && p->get_y1() < 0  &&  p->get_x2() < bathLength+channelLength)
			|| (p->get_x2() > bathLength+channelLength && p->get_y2() < 0  &&  p->get_x1() < bathLength+channelLength)) 
			{
				p=delLinesList.erase(p);
				removed=true;	
			} 
			
			if ((p->get_x1() > bathLength+channelLength && p->get_y1() > channelWidth+b0  &&  p->get_x2() < bathLength+channelLength)
			|| (p->get_x2() > bathLength+channelLength && p->get_y2() > channelWidth+b0  &&  p->get_x1() < bathLength+channelLength)) 
			{
				p=delLinesList.erase(p);
				removed=true;	
			} 
			
		
			if (removed==false) { ++p; }
		}
	}
	else if (tube==geometry)
	{
		while (p != delLinesList.end())
		{
			bool removed=false;
		
			
			if (p->get_y1() <= removetopchannely || p->get_y2() <= removetopchannely ||
				p->get_y1() >=removebottomchannely || p->get_y2() >= removebottomchannely)
			{
				p=delLinesList.erase(p);
				removed=true;	
			} 
		
			if (removed==false) { ++p; }
		}
	}
	
	//std::cout << "Triangulation finished" << std::endl;
	
}

void CSimulation::next_t()
{
	if (!is_paused())
		t++;
}

double CSimulation::calcSinkB()
{
	
	normaliseSinkStr = "";
	
	double aaverage=0;
	int numa=0;
	for (std::list<CDelLine>::iterator p = delLinesList.begin();
				p!=delLinesList.end(); ++p) {
		double midy = (p->get_y1() + p->get_y2())/2.0;
		double midx = (p->get_x1() + p->get_x2())/2.0;
						
		if ( (midx > bathLength+channelLength-binsize/2.0 && midx<bathLength+channelLength+binsize/2.0) &&
				(midy>0 && midy<channelWidth)) {
			//continue;
			double linelength=sqrt((double) (p->get_x1()-p->get_x2())*(p->get_x1()-p->get_x2())
																		+ (p->get_y1()-p->get_y2())*(p->get_y1()-p->get_y2()));
											
			aaverage=aaverage+linelength;
			numa++;	
		}				
	}
	aaverage=aaverage/(double)numa;
	
	double Beff=2*Phi/(sqrt((double)3)*aaverage*aaverage);		
	std::ostringstream oss;
	oss.str("");
	
	oss << "Br(x="<<(bathLength+channelLength)/a0<<"a0)=" << Beff << "T";
	
	normaliseSinkStr = oss.str();	
	
	return Beff;
	
}

double CSimulation::calcSourceB()
{
	normaliseSourceStr = "";
	double aaverage=0;
	int numa=0;
	for (std::list<CDelLine>::iterator p = delLinesList.begin();
				p!=delLinesList.end(); ++p) {
		double midy = (p->get_y1() + p->get_y2())/2.0;
		double midx = (p->get_x1() + p->get_x2())/2.0;
						
		if ( midx> bathLength-binsize/2.0 && midx < bathLength+binsize/2.0 &&
				(midy>0 && midy<channelWidth))
		{
			double linelength=sqrt((double) (p->get_x1()-p->get_x2())*(p->get_x1()-p->get_x2())
																		+ (p->get_y1()-p->get_y2())*(p->get_y1()-p->get_y2()));
											
			aaverage=aaverage+linelength;
			numa++;	
		}			
	}
	aaverage=aaverage/(double)numa;
	
	double Beff=2*Phi/(sqrt((double)3)*aaverage*aaverage);		
	std::ostringstream oss;
	oss.str("");
	
	oss << "Bl(x="<<bathLength/a0<<"a0)=" << Beff << "T";
	
	normaliseSourceStr = oss.str();	
	
	return Beff;
	
}

void CSimulation::zoom_in()
{
	zoom*=5.0/4.0;
}

void CSimulation::zoom_out()
{
	zoom*=4.0/5.0;
}

double CSimulation::get_zoom() const
{
	return zoom;
}

void CSimulation::calcRowCount()
{
	// this alogorithm will count the number of rows at 5a0, 15a0, 25a0 etc
	rowCountLinesVector.clear();
	
	CParticle startParticle(30*a0,10*a0,0,0,0);
	
	CParticle closest = findClosestParticle(startParticle);
	
	
	CDelLine newLine(closest.get_x(),closest.get_y(),5*a0,5*a0);
	rowCountLinesVector.push_back(newLine);
	CDelLine newLine2(5*a0,5*a0,10*a0,5*a0);
	rowCountLinesVector.push_back(newLine2);


	CRowCount newRow(5*a0+bathLength,10);
	rowCount.push_back(newRow);
	
	CRowCount newRow2(15*a0+bathLength,9);
	rowCount.push_back(newRow2);

	

}

CParticle CSimulation::findClosestParticle (CParticle a_)
{
	//std::vector<CParticle> vorticesVector;
  //std::copy( vorticesList_.begin(), vorticesList_.end(), std::back_inserter( vorticesVector ) );
  
	int j = 0;
	
	double smallest=100*a0;
	
	CParticle* result;
	
  for (std::list<CParticle>::iterator p = vorticesList.begin();
			p != vorticesList.end(); ++p)
	{
			
		double ds2 = (p->get_x() - a_.get_x())*(p->get_x() - a_.get_x())+
									(p->get_y() - a_.get_y())*(p->get_y() - a_.get_y());
      
    if (smallest > ds2)
    {
			smallest = ds2;
			result = &(*p);
    }
    
   }
   
   return (*result);
 

}


void CSimulation::calculateBinnedvelocityProfile() {
	// This routine calculates the velocity field using
	// the time and space averages ( over bins) method 
	// uses running mean and average method
	
	// only add data point to bin if velocities are uncorrelated
	
	for (std::list<CParticle>::iterator p=vorticesList.begin();
			p!=vorticesList.end(); ++p)
	{
		int i = what_ivfieldBin(*p);
		int j = what_jvfieldBin(*p);
		
		vfieldBinVx[i][j].add(p->get_velx());
		vfieldBinVy[i][j].add(p->get_vely());
	
	}
	
	
	
	
	if (t==simulation_time)
	{
		for (int i=0; i<MAXVFIELDBINS;i++)
			for (int j=0; j<MAXVFIELDBINS;j++)
			{	
				if (0==vfieldBinVx[i][j].get_numDataPoints())
					continue;
				double x = get_firstPin().get_x()+(i+0.5)*vfieldBinSize; 
				double y = get_firstPin().get_y()+(j+0.5)*vfieldBinSize;
				
				vfieldAvfile << x << "  " << y << "  " << vfieldBinVx[i][j].get_mean() << "  " << vfieldBinVx[i][j].get_variance() << "  " << vfieldBinVx[i][j].get_numDataPoints() << "  "  
																							 <<	vfieldBinVy[i][j].get_mean() << "  " << vfieldBinVy[i][j].get_variance() << "  " << vfieldBinVx[i][j].get_numDataPoints() << std::endl; 
		
		
			}
	}
	
	
	
	
	
}


void CSimulation::updateTrajectories()
{
	/*if (simulation_time==t)
	{
		int trajcount=0;
		for (std::list<CParticle>::iterator p = vorticesList.begin();
			p!= vorticesList.end(); ++p )
		{
				trajfile << "Trajectory: " << trajcount;
				
				int numpoints=p->get_numTrajPoints();
				
				trajfile << "  NumPoints: " << numpoints << std::endl;
				for (int q=0; q<numpoints;q++)
				{
						trajfile << (*(p->get_trajectoryx()))[q] << "  " << (*(p->get_trajectoryy()))[q] << std::endl;
			
			
				}
				trajfile << std::endl;
				trajcount++;
		}
	
		
		
	}*/
	
	if (0!=t%25) return;
	
	for (std::list<CParticle>::iterator p = vorticesList.begin();
			p!= vorticesList.end(); ++p )
	{
			p->add_trajectoryPoint();
	}
	
	
}

void CSimulation::escapedTrajectoryOutput(std::list<CParticle>::iterator p_)
{	
	static int numOutputTraj=0;
	numOutputTraj++;
	// output final position
			
	p_->add_trajectoryPoint();

	// output trajectory to file

	trajfile << "Trajectory: " << numOutputTraj;
		
	int numpoints=p_->get_numTrajPoints();
		
	trajfile << "  NumPoints: " << numpoints << std::endl;
	for (int q=0; q<numpoints;q++)
	{
			trajfile << (*(p_->get_trajectoryx()))[q] << "  " << (*(p_->get_trajectoryy()))[q] << std::endl;


	}
	trajfile << std::endl;
}
